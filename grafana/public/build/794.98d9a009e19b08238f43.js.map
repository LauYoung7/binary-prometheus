{"version":3,"file":"794.98d9a009e19b08238f43.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx","webpack://grafana/./public/app/plugins/datasource/loki/LanguageProvider.ts","webpack://grafana/../../opt/drone/yarncache/rxjs-npm-7.5.7-602d5c56e4-edabcdb73b.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js","webpack://grafana/../../opt/drone/yarncache/rxjs-npm-7.5.7-602d5c56e4-edabcdb73b.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js","webpack://grafana/../../opt/drone/yarncache/uuid-npm-9.0.0-46c41e3e43-8dd2c83c43.zip/node_modules/uuid/dist/esm-browser/regex.js","webpack://grafana/../../opt/drone/yarncache/uuid-npm-9.0.0-46c41e3e43-8dd2c83c43.zip/node_modules/uuid/dist/esm-browser/validate.js","webpack://grafana/../../opt/drone/yarncache/uuid-npm-9.0.0-46c41e3e43-8dd2c83c43.zip/node_modules/uuid/dist/esm-browser/parse.js","webpack://grafana/../../opt/drone/yarncache/uuid-npm-9.0.0-46c41e3e43-8dd2c83c43.zip/node_modules/uuid/dist/esm-browser/v35.js","webpack://grafana/../../opt/drone/yarncache/uuid-npm-9.0.0-46c41e3e43-8dd2c83c43.zip/node_modules/uuid/dist/esm-browser/sha1.js","webpack://grafana/../../opt/drone/yarncache/uuid-npm-9.0.0-46c41e3e43-8dd2c83c43.zip/node_modules/uuid/dist/esm-browser/v5.js","webpack://grafana/./public/app/plugins/datasource/loki/liveStreamsResultTransformer.ts","webpack://grafana/./public/app/plugins/datasource/loki/LiveStreams.ts","webpack://grafana/./public/app/plugins/datasource/loki/getDerivedFields.ts","webpack://grafana/./public/app/plugins/datasource/loki/makeTableFrames.ts","webpack://grafana/./public/app/plugins/datasource/loki/backendResultTransformer.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/AnnotationsQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiContextUi.tsx","webpack://grafana/./public/app/plugins/datasource/loki/migrations/variableQueryMigrations.ts","webpack://grafana/./public/app/plugins/datasource/loki/queryHints.ts","webpack://grafana/./public/app/plugins/datasource/loki/sortDataFrame.ts","webpack://grafana/./public/app/plugins/datasource/loki/streaming.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/VariableQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/variables.ts","webpack://grafana/./public/app/plugins/datasource/loki/datasource.ts","webpack://grafana/./public/app/plugins/datasource/loki/modifyQuery.ts","webpack://grafana/./public/app/plugins/datasource/loki/queryUtils.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/components/UnwrapParamEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/operationUtils.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/operations.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/parsing.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/types.ts","webpack://grafana/./public/app/plugins/datasource/loki/lineParser.ts","webpack://grafana/./public/app/plugins/datasource/loki/responseUtils.ts","webpack://grafana/./public/app/plugins/datasource/loki/syntax.ts","webpack://grafana/./public/app/plugins/datasource/loki/tracking.ts","webpack://grafana/./public/app/plugins/datasource/loki/types.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts","webpack://grafana/./.yarn/__virtual__/@grafana-lezer-logql-virtual-8344126d4a/3/opt/drone/yarncache/@grafana-lezer-logql-npm-0.1.1-db77ec9761-b0d71e5670.zip/node_modules/@grafana/lezer-logql/index.es.js"],"sourcesContent":["// Libraries\nimport { css, cx } from '@emotion/css';\nimport { map } from 'lodash';\nimport React, { memo } from 'react';\n\n// Types\nimport { SelectableValue } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { InlineFormLabel, RadioButtonGroup, InlineField, Input, Select } from '@grafana/ui';\n\nimport { LokiQuery, LokiQueryType } from '../types';\n\nexport interface LokiOptionFieldsProps {\n  lineLimitValue: string;\n  resolution: number;\n  query: LokiQuery;\n  onChange: (value: LokiQuery) => void;\n  onRunQuery: () => void;\n  runOnBlur?: boolean;\n}\n\nexport const queryTypeOptions: Array<SelectableValue<LokiQueryType>> = [\n  { value: LokiQueryType.Range, label: 'Range', description: 'Run query over a range of time.' },\n  {\n    value: LokiQueryType.Instant,\n    label: 'Instant',\n    description: 'Run query against a single point in time. For this query, the \"To\" time is used.',\n  },\n];\n\nif (config.featureToggles.lokiLive) {\n  queryTypeOptions.push({\n    value: LokiQueryType.Stream,\n    label: 'Stream',\n    description: 'Run a query and keep sending results on an interval',\n  });\n}\n\nexport const DEFAULT_RESOLUTION: SelectableValue<number> = {\n  value: 1,\n  label: '1/1',\n};\n\nexport const RESOLUTION_OPTIONS: Array<SelectableValue<number>> = [DEFAULT_RESOLUTION].concat(\n  map([2, 3, 4, 5, 10], (value: number) => ({\n    value,\n    label: '1/' + value,\n  }))\n);\n\nexport function LokiOptionFields(props: LokiOptionFieldsProps) {\n  const { lineLimitValue, resolution, onRunQuery, runOnBlur, onChange } = props;\n  const query = props.query ?? {};\n  let queryType = query.queryType ?? (query.instant ? LokiQueryType.Instant : LokiQueryType.Range);\n\n  function onChangeQueryLimit(value: string) {\n    const nextQuery = { ...query, maxLines: preprocessMaxLines(value) };\n    onChange(nextQuery);\n  }\n\n  function onQueryTypeChange(queryType: LokiQueryType) {\n    const { instant, range, ...rest } = query;\n    onChange({ ...rest, queryType });\n  }\n\n  function onMaxLinesChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (query.maxLines !== preprocessMaxLines(e.currentTarget.value)) {\n      onChangeQueryLimit(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter') {\n      onRunQuery();\n    }\n  }\n\n  function onResolutionChange(option: SelectableValue<number>) {\n    const nextQuery = { ...query, resolution: option.value };\n    onChange(nextQuery);\n  }\n\n  return (\n    <div aria-label=\"Loki extra field\" className=\"gf-form-inline\">\n      {/*Query type field*/}\n      <div\n        data-testid=\"queryTypeField\"\n        className={cx(\n          'gf-form explore-input-margin',\n          css`\n            flex-wrap: nowrap;\n          `\n        )}\n        aria-label=\"Query type field\"\n      >\n        <InlineFormLabel width=\"auto\">Query type</InlineFormLabel>\n\n        <RadioButtonGroup\n          options={queryTypeOptions}\n          value={queryType}\n          onChange={(type: LokiQueryType) => {\n            onQueryTypeChange(type);\n            if (runOnBlur) {\n              onRunQuery();\n            }\n          }}\n        />\n      </div>\n      {/*Line limit field*/}\n      <div\n        data-testid=\"lineLimitField\"\n        className={cx(\n          'gf-form',\n          css`\n            flex-wrap: nowrap;\n          `\n        )}\n        aria-label=\"Line limit field\"\n      >\n        <InlineField label=\"Line limit\" tooltip={'Upper limit for number of log lines returned by query.'}>\n          <Input\n            className=\"width-4\"\n            placeholder=\"auto\"\n            type=\"number\"\n            min={0}\n            onChange={onMaxLinesChange}\n            onKeyDown={onReturnKeyDown}\n            value={lineLimitValue}\n            onBlur={() => {\n              if (runOnBlur) {\n                onRunQuery();\n              }\n            }}\n          />\n        </InlineField>\n        <InlineField\n          label=\"Resolution\"\n          tooltip={\n            'Resolution 1/1 sets step parameter of Loki metrics range queries such that each pixel corresponds to one data point. For better performance, lower resolutions can be picked. 1/2 only retrieves a data point for every other pixel, and 1/10 retrieves one data point per 10 pixels.'\n          }\n        >\n          <Select\n            isSearchable={false}\n            onChange={onResolutionChange}\n            options={RESOLUTION_OPTIONS}\n            value={resolution}\n            aria-label=\"Select resolution\"\n          />\n        </InlineField>\n      </div>\n    </div>\n  );\n}\n\nexport default memo(LokiOptionFields);\n\nexport function preprocessMaxLines(value: string): number {\n  if (value.length === 0) {\n    // empty input - falls back to dataSource.maxLines limit\n    return NaN;\n  } else if (value.length > 0 && (isNaN(+value) || +value < 0)) {\n    // input with at least 1 character and that is either incorrect (value in the input field is not a number) or negative\n    // falls back to the limit of 0 lines\n    return 0;\n  } else {\n    // default case - correct input\n    return +value;\n  }\n}\n","import { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\nimport Prism, { Grammar } from 'prismjs';\n\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem, AbstractQuery } from '@grafana/data';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport {\n  extractLabelMatchers,\n  parseSelector,\n  processLabels,\n  toPromLikeExpr,\n} from 'app/plugins/datasource/prometheus/language_utils';\n\nimport { LokiDatasource } from './datasource';\nimport {\n  extractLabelKeysFromDataFrame,\n  extractLogParserFromDataFrame,\n  extractUnwrapLabelKeysFromDataFrame,\n} from './responseUtils';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\nimport { LokiQuery, LokiQueryType } from './types';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\n\n// When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\nconst RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortValue: '$__interval' },\n  { label: '$__range', sortValue: '$__range' },\n  { label: '1m', sortValue: '00:01:00' },\n  { label: '5m', sortValue: '00:05:00' },\n  { label: '10m', sortValue: '00:10:00' },\n  { label: '30m', sortValue: '00:30:00' },\n  { label: '1h', sortValue: '01:00:00' },\n  { label: '1d', sortValue: '24:00:00' },\n];\n\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label, filterText: `\\\"${label}\\\"` });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  labelFetchTs: number;\n  started = false;\n  datasource: LokiDatasource;\n  lookupsDisabled = false; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>({ max: 10 });\n  private labelsCache = new LRU<string, string[]>({ max: 10 });\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLabels().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history?.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map((suggestion) => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getPipeCompletionItem = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      label: 'Operators',\n      items: PIPE_OPERATORS.map((suggestion) => ({ ...suggestion, kind: 'operators' })),\n    });\n\n    suggestions.push({\n      label: 'Parsers',\n      items: PIPE_PARSERS.map((suggestion) => ({ ...suggestion, kind: 'parsers' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems({ text, wrapperClasses, labelKey, value }: TypeaheadInput): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `Labels`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({ filterText }) => filterText !== text),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  importFromAbstractQuery(labelBasedQuery: AbstractQuery): LokiQuery {\n    return {\n      refId: labelBasedQuery.refId,\n      expr: toPromLikeExpr(labelBasedQuery),\n      queryType: LokiQueryType.Range,\n    };\n  }\n\n  exportToAbstractQuery(query: LokiQuery): AbstractQuery {\n    const lokiQuery = query.expr;\n    if (!lokiQuery || lokiQuery.length === 0) {\n      return { refId: query.refId, labelMatchers: [] };\n    }\n    const tokens = Prism.tokenize(lokiQuery, syntax);\n    return {\n      refId: query.refId,\n      labelMatchers: extractLabelMatchers(tokens),\n    };\n  }\n\n  async getSeriesLabels(selector: string) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = 'labels';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, timeRange);\n    if (Array.isArray(res)) {\n      const labels = res\n        .slice()\n        .sort()\n        .filter((label) => label !== '__name__');\n      this.labelKeys = labels;\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by its args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string): Promise<Record<string, string[]>> => {\n    const interpolatedMatch = this.datasource.interpolateString(match);\n    const url = 'series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n\n    const cacheKey = this.generateCacheKey(url, start, end, interpolatedMatch);\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const params = { 'match[]': interpolatedMatch, start, end };\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = 'series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n    const params = { 'match[]': match, start, end };\n    return await this.request(url, params);\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key: string): Promise<string[]> {\n    const interpolatedKey = encodeURIComponent(this.datasource.interpolateString(key));\n\n    const url = `label/${interpolatedKey}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, interpolatedKey);\n    const params = { start, end };\n\n    let labelValues = this.labelsCache.get(cacheKey);\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return labelValues ?? [];\n  }\n\n  async getParserAndLabelKeys(\n    selector: string\n  ): Promise<{ extractedLabelKeys: string[]; hasJSON: boolean; hasLogfmt: boolean; unwrapLabelKeys: string[] }> {\n    const series = await this.datasource.getDataSamples({ expr: selector, refId: 'data-samples' });\n\n    if (!series.length) {\n      return { extractedLabelKeys: [], unwrapLabelKeys: [], hasJSON: false, hasLogfmt: false };\n    }\n\n    const { hasLogfmt, hasJSON } = extractLogParserFromDataFrame(series[0]);\n\n    return {\n      extractedLabelKeys: extractLabelKeysFromDataFrame(series[0]),\n      unwrapLabelKeys: extractUnwrapLabelKeysFromDataFrame(series[0]),\n      hasJSON,\n      hasLogfmt,\n    };\n  }\n}\n","import { __assign, __extends } from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        _this._socket = null;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = (_this._config = __assign({}, DEFAULT_WEBSOCKET_CONFIG));\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe({\n                next: function (x) {\n                    try {\n                        if (messageFilter(x)) {\n                            observer.next(x);\n                        }\n                    }\n                    catch (err) {\n                        observer.error(err);\n                    }\n                },\n                error: function (err) { return observer.error(err); },\n                complete: function () { return observer.complete(); },\n            });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (evt) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(evt);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (err) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (err && err.code) {\n                    socket.close(err.code, err.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            if (socket === _this._socket) {\n                _this._resetState();\n            }\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map","import { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import { v5 as uuidv5 } from 'uuid';\n\nimport { MutableDataFrame } from '@grafana/data';\n\nimport { LokiStreamResult, LokiTailResponse } from './types';\n\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  const tsField = data.fields[0];\n  const lineField = data.fields[1];\n  const idField = data.fields[2];\n\n  // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n  const usedUids: { string?: number } = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());\n      lineField.values.add(line);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string, usedUids: any, refId?: string): string {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE);\n\n  // Check if generated id is unique\n  // If not and we've already used it, append its count after it\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount;\n    // Append count to generated id to make it unique\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  }\n  // Return unique id\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n  return id;\n}\n","import { Observable, throwError, timer } from 'rxjs';\nimport { finalize, map, retryWhen, mergeMap } from 'rxjs/operators';\nimport { webSocket } from 'rxjs/webSocket';\n\nimport { DataFrame, FieldType, KeyValue, CircularDataFrame } from '@grafana/data';\n\nimport { appendResponseToBufferedData } from './liveStreamsResultTransformer';\nimport { LokiTailResponse } from './types';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LokiLiveTarget {\n  query: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LokiLiveTarget, retryInterval = 5000): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n\n    if (stream) {\n      return stream;\n    }\n\n    const data = new CircularDataFrame({ capacity: target.size });\n    data.addField({ name: 'Time', type: FieldType.time, config: {} });\n    data.addField({ name: 'Line', type: FieldType.string });\n    data.addField({ name: 'id', type: FieldType.string });\n    data.meta = { ...data.meta, preferredVisualisationType: 'logs' };\n    data.refId = target.refId;\n\n    stream = webSocket<LokiTailResponse>(target.url).pipe(\n      map((response: LokiTailResponse) => {\n        appendResponseToBufferedData(response, data);\n        return [data];\n      }),\n      retryWhen((attempts: Observable<any>) =>\n        attempts.pipe(\n          mergeMap((error, i) => {\n            const retryAttempt = i + 1;\n            // Code 1006 is used to indicate that a connection was closed abnormally.\n            // Added hard limit of 30 on number of retries.\n            // If connection was closed abnormally, and we wish to retry, otherwise throw error.\n            if (error.code === 1006 && retryAttempt < 30) {\n              if (retryAttempt > 10) {\n                // If more than 10 times retried, consol.warn, but keep reconnecting\n                console.warn(\n                  `Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`\n                );\n              }\n              // Retry every 5s\n              return timer(retryInterval);\n            }\n            return throwError(error);\n          })\n        )\n      ),\n      finalize(() => {\n        delete this.streams[target.url];\n      })\n    );\n    this.streams[target.url] = stream;\n\n    return stream;\n  }\n}\n","import { groupBy } from 'lodash';\n\nimport { FieldType, DataFrame, ArrayVector, DataLink, Field } from '@grafana/data';\nimport { getDataSourceSrv } from '@grafana/runtime';\n\nimport { DerivedFieldConfig } from './types';\n\nexport function getDerivedFields(dataFrame: DataFrame, derivedFieldConfigs: DerivedFieldConfig[]): Field[] {\n  if (!derivedFieldConfigs.length) {\n    return [];\n  }\n  const derivedFieldsGrouped = groupBy(derivedFieldConfigs, 'name');\n\n  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);\n\n  // line-field is the first string-field\n  // NOTE: we should create some common log-frame-extra-string-field code somewhere\n  const lineField = dataFrame.fields.find((f) => f.type === FieldType.string);\n\n  if (lineField === undefined) {\n    // if this is happening, something went wrong, let's raise an error\n    throw new Error('invalid logs-dataframe, string-field missing');\n  }\n\n  lineField.values.toArray().forEach((line) => {\n    for (const field of newFields) {\n      const logMatch = line.match(derivedFieldsGrouped[field.name][0].matcherRegex);\n      field.values.add(logMatch && logMatch[1]);\n    }\n  });\n\n  return newFields;\n}\n\n/**\n * Transform derivedField config into dataframe field with config that contains link.\n */\nfunction fieldFromDerivedFieldConfig(derivedFieldConfigs: DerivedFieldConfig[]): Field<any, ArrayVector> {\n  const dataSourceSrv = getDataSourceSrv();\n\n  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {\n    // Having field.datasourceUid means it is an internal link.\n    if (derivedFieldConfig.datasourceUid) {\n      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);\n\n      acc.push({\n        // Will be filled out later\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        url: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        internal: {\n          query: { query: derivedFieldConfig.url },\n          datasourceUid: derivedFieldConfig.datasourceUid,\n          datasourceName: dsSettings?.name ?? 'Data source not found',\n        },\n      });\n    } else if (derivedFieldConfig.url) {\n      acc.push({\n        // We do not know what title to give here so we count on presentation layer to create a title from metadata.\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        url: derivedFieldConfig.url,\n      });\n    }\n    return acc;\n  }, [] as DataLink[]);\n\n  return {\n    name: derivedFieldConfigs[0].name,\n    type: FieldType.string,\n    config: {\n      links: dataLinks,\n    },\n    // We are adding values later on\n    values: new ArrayVector<string>([]),\n  };\n}\n","import { groupBy } from 'lodash';\n\nimport { DataFrame, Field, FieldType, ArrayVector } from '@grafana/data';\n\nexport function makeTableFrames(instantMetricFrames: DataFrame[]): DataFrame[] {\n  // first we remove frames that have no refId\n  // (we will group them by refId, so we need it to be set)\n  const framesWithRefId = instantMetricFrames.filter((f) => f.refId !== undefined);\n\n  const framesByRefId = groupBy(framesWithRefId, (frame) => frame.refId);\n\n  return Object.entries(framesByRefId).map(([refId, frames]) => makeTableFrame(frames, refId));\n}\n\ntype NumberField = Field<number, ArrayVector<number>>;\ntype StringField = Field<string, ArrayVector<string>>;\n\nfunction makeTableFrame(instantMetricFrames: DataFrame[], refId: string): DataFrame {\n  const tableTimeField: NumberField = { name: 'Time', config: {}, values: new ArrayVector(), type: FieldType.time };\n  const tableValueField: NumberField = {\n    name: `Value #${refId}`,\n    config: {},\n    values: new ArrayVector(),\n    type: FieldType.number,\n  };\n\n  // Sort metric labels, create columns for them and record their index\n  const allLabelNames = new Set(\n    instantMetricFrames.map((frame) => frame.fields.map((field) => Object.keys(field.labels ?? {})).flat()).flat()\n  );\n\n  const sortedLabelNames = Array.from(allLabelNames).sort();\n\n  const labelFields: StringField[] = sortedLabelNames.map((labelName) => ({\n    name: labelName,\n    config: { filterable: true },\n    values: new ArrayVector(),\n    type: FieldType.string,\n  }));\n\n  instantMetricFrames.forEach((frame) => {\n    const timeField = frame.fields.find((field) => field.type === FieldType.time);\n    const valueField = frame.fields.find((field) => field.type === FieldType.number);\n    if (timeField == null || valueField == null) {\n      return;\n    }\n\n    const timeArray = timeField.values.toArray();\n    const valueArray = valueField.values.toArray();\n\n    for (let x of timeArray) {\n      tableTimeField.values.add(x);\n    }\n\n    for (let x of valueArray) {\n      tableValueField.values.add(x);\n    }\n\n    const labels = valueField.labels ?? {};\n\n    for (let f of labelFields) {\n      const text = labels[f.name] ?? '';\n      // we insert the labels as many times as we have values\n      for (let i = 0; i < valueArray.length; i++) {\n        f.values.add(text);\n      }\n    }\n  });\n\n  return {\n    fields: [tableTimeField, ...labelFields, tableValueField],\n    refId,\n    meta: { preferredVisualisationType: 'table' },\n    length: tableTimeField.values.length,\n  };\n}\n","import { DataQueryResponse, DataFrame, isDataFrame, FieldType, QueryResultMeta, DataQueryError } from '@grafana/data';\n\nimport { getDerivedFields } from './getDerivedFields';\nimport { makeTableFrames } from './makeTableFrames';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './queryUtils';\nimport { dataFrameHasLokiError } from './responseUtils';\nimport { DerivedFieldConfig, LokiQuery, LokiQueryType } from './types';\n\nfunction isMetricFrame(frame: DataFrame): boolean {\n  return frame.fields.every((field) => field.type === FieldType.time || field.type === FieldType.number);\n}\n\n// returns a new frame, with meta shallow merged with its original meta\nfunction setFrameMeta(frame: DataFrame, meta: QueryResultMeta): DataFrame {\n  const { meta: oldMeta, ...rest } = frame;\n  // meta maybe be undefined, we need to handle that\n  const newMeta = { ...oldMeta, ...meta };\n  return {\n    ...rest,\n    meta: newMeta,\n  };\n}\n\nfunction processStreamFrame(\n  frame: DataFrame,\n  query: LokiQuery | undefined,\n  derivedFieldConfigs: DerivedFieldConfig[]\n): DataFrame {\n  const custom: Record<string, string> = {\n    ...frame.meta?.custom, // keep the original meta.custom\n    // used by logsModel\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  if (dataFrameHasLokiError(frame)) {\n    custom.error = 'Error when parsing some of the logs';\n  }\n\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'logs',\n    limit: query?.maxLines,\n    searchWords: query !== undefined ? getHighlighterExpressionsFromQuery(formatQuery(query.expr)) : undefined,\n    custom,\n  };\n\n  const newFrame = setFrameMeta(frame, meta);\n  const derivedFields = getDerivedFields(newFrame, derivedFieldConfigs);\n  return {\n    ...newFrame,\n    fields: [...newFrame.fields, ...derivedFields],\n  };\n}\n\nfunction processStreamsFrames(\n  frames: DataFrame[],\n  queryMap: Map<string, LokiQuery>,\n  derivedFieldConfigs: DerivedFieldConfig[]\n): DataFrame[] {\n  return frames.map((frame) => {\n    const query = frame.refId !== undefined ? queryMap.get(frame.refId) : undefined;\n    return processStreamFrame(frame, query, derivedFieldConfigs);\n  });\n}\n\nfunction processMetricInstantFrames(frames: DataFrame[]): DataFrame[] {\n  return frames.length > 0 ? makeTableFrames(frames) : [];\n}\n\nfunction processMetricRangeFrames(frames: DataFrame[]): DataFrame[] {\n  const meta: QueryResultMeta = { preferredVisualisationType: 'graph' };\n  return frames.map((frame) => setFrameMeta(frame, meta));\n}\n\n// we split the frames into 3 groups, because we will handle\n// each group slightly differently\nfunction groupFrames(\n  frames: DataFrame[],\n  queryMap: Map<string, LokiQuery>\n): {\n  streamsFrames: DataFrame[];\n  metricInstantFrames: DataFrame[];\n  metricRangeFrames: DataFrame[];\n} {\n  const streamsFrames: DataFrame[] = [];\n  const metricInstantFrames: DataFrame[] = [];\n  const metricRangeFrames: DataFrame[] = [];\n\n  frames.forEach((frame) => {\n    if (!isMetricFrame(frame)) {\n      streamsFrames.push(frame);\n    } else {\n      const isInstantFrame = frame.refId != null && queryMap.get(frame.refId)?.queryType === LokiQueryType.Instant;\n      if (isInstantFrame) {\n        metricInstantFrames.push(frame);\n      } else {\n        metricRangeFrames.push(frame);\n      }\n    }\n  });\n\n  return { streamsFrames, metricInstantFrames, metricRangeFrames };\n}\n\nfunction improveError(error: DataQueryError | undefined, queryMap: Map<string, LokiQuery>): DataQueryError | undefined {\n  // many things are optional in an error-object, we need an error-message to exist,\n  // and we need to find the loki-query, based on the refId in the error-object.\n  if (error === undefined) {\n    return error;\n  }\n\n  const { refId, message } = error;\n  if (refId === undefined || message === undefined) {\n    return error;\n  }\n\n  const query = queryMap.get(refId);\n  if (query === undefined) {\n    return error;\n  }\n\n  if (message.includes('escape') && query.expr.includes('\\\\')) {\n    return {\n      ...error,\n      message: `${message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`,\n    };\n  }\n\n  return error;\n}\n\nexport function transformBackendResult(\n  response: DataQueryResponse,\n  queries: LokiQuery[],\n  derivedFieldConfigs: DerivedFieldConfig[]\n): DataQueryResponse {\n  const { data, error, ...rest } = response;\n\n  // in the typescript type, data is an array of basically anything.\n  // we do know that they have to be dataframes, so we make a quick check,\n  // this way we can be sure, and also typescript is happy.\n  const dataFrames = data.map((d) => {\n    if (!isDataFrame(d)) {\n      throw new Error('transformation only supports dataframe responses');\n    }\n    return d;\n  });\n\n  const queryMap = new Map(queries.map((query) => [query.refId, query]));\n\n  const { streamsFrames, metricInstantFrames, metricRangeFrames } = groupFrames(dataFrames, queryMap);\n\n  return {\n    ...rest,\n    error: improveError(error, queryMap),\n    data: [\n      ...processMetricRangeFrames(metricRangeFrames),\n      ...processMetricInstantFrames(metricInstantFrames),\n      ...processStreamsFrames(streamsFrames, queryMap, derivedFieldConfigs),\n    ],\n  };\n}\n","// Libraries\nimport React, { memo } from 'react';\n\nimport { AnnotationQuery } from '@grafana/data';\nimport { EditorField, EditorRow } from '@grafana/experimental';\nimport { Input } from '@grafana/ui';\n\n// Types\nimport { getNormalizedLokiQuery } from '../queryUtils';\nimport { LokiQuery, LokiQueryType } from '../types';\n\nimport { LokiOptionFields } from './LokiOptionFields';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiQueryEditorProps } from './types';\n\ntype Props = LokiQueryEditorProps & {\n  annotation?: AnnotationQuery<LokiQuery>;\n  onAnnotationChange?: (annotation: AnnotationQuery<LokiQuery>) => void;\n};\n\nexport const LokiAnnotationsQueryEditor = memo(function LokiAnnotationQueryEditor(props: Props) {\n  const { annotation, onAnnotationChange, history } = props;\n\n  // this should never happen, but we want to keep typescript happy\n  if (annotation === undefined || onAnnotationChange === undefined) {\n    return null;\n  }\n\n  const onChangeQuery = (query: LokiQuery) => {\n    // the current version of annotations only stores an optional boolean\n    // field `instant` to handle the instant/range switch.\n    // we need to maintain compatibility for now, so we do the same.\n    // we explicitly call `getNormalizedLokiQuery` to make sure `queryType`\n    // is set up correctly.\n    const instant = getNormalizedLokiQuery(query).queryType === LokiQueryType.Instant;\n    onAnnotationChange({\n      ...annotation,\n      expr: query.expr,\n      maxLines: query.maxLines,\n      instant,\n    });\n  };\n\n  const queryWithRefId: LokiQuery = {\n    refId: '',\n    expr: annotation.expr,\n    maxLines: annotation.maxLines,\n    instant: annotation.instant,\n    queryType: annotation.queryType,\n  };\n  return (\n    <>\n      <div className=\"gf-form-group\">\n        <LokiQueryField\n          datasource={props.datasource}\n          query={queryWithRefId}\n          onChange={onChangeQuery}\n          onRunQuery={() => {}}\n          onBlur={() => {}}\n          history={history}\n          ExtraFieldElement={\n            <LokiOptionFields\n              lineLimitValue={queryWithRefId?.maxLines?.toString() || ''}\n              resolution={queryWithRefId.resolution || 1}\n              query={queryWithRefId}\n              onRunQuery={() => {}}\n              onChange={onChangeQuery}\n            />\n          }\n        />\n      </div>\n\n      <EditorRow>\n        <EditorField\n          label=\"Title\"\n          tooltip={\n            'Use either the name or a pattern. For example, {{instance}} is replaced with label value for the label instance.'\n          }\n        >\n          <Input\n            type=\"text\"\n            placeholder=\"alertname\"\n            value={annotation.titleFormat}\n            onChange={(event) => {\n              onAnnotationChange({\n                ...annotation,\n                titleFormat: event.currentTarget.value,\n              });\n            }}\n          />\n        </EditorField>\n        <EditorField label=\"Tags\">\n          <Input\n            type=\"text\"\n            placeholder=\"label1,label2\"\n            value={annotation.tagKeys}\n            onChange={(event) => {\n              onAnnotationChange({\n                ...annotation,\n                tagKeys: event.currentTarget.value,\n              });\n            }}\n          />\n        </EditorField>\n        <EditorField\n          label=\"Text\"\n          tooltip={\n            'Use either the name or a pattern. For example, {{instance}} is replaced with label value for the label instance.'\n          }\n        >\n          <Input\n            type=\"text\"\n            placeholder=\"instance\"\n            value={annotation.textFormat}\n            onChange={(event) => {\n              onAnnotationChange({\n                ...annotation,\n                textFormat: event.currentTarget.value,\n              });\n            }}\n          />\n        </EditorField>\n      </EditorRow>\n    </>\n  );\n});\n","import { css } from '@emotion/css';\nimport memoizeOne from 'memoize-one';\nimport React, { useEffect, useState } from 'react';\nimport { useAsync } from 'react-use';\n\nimport { GrafanaTheme2, LogRowModel, SelectableValue } from '@grafana/data';\nimport { reportInteraction } from '@grafana/runtime';\nimport { MultiSelect, Tag, Tooltip, useStyles2 } from '@grafana/ui';\n\nimport LokiLanguageProvider from '../LanguageProvider';\nimport { ContextFilter } from '../types';\n\nexport interface LokiContextUiProps {\n  languageProvider: LokiLanguageProvider;\n  row: LogRowModel;\n  updateFilter: (value: ContextFilter[]) => void;\n  onClose: () => void;\n}\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    labels: css`\n      display: flex;\n      gap: 2px;\n    `,\n    multiSelectWrapper: css`\n      display: flex;\n      flex-direction: column;\n      flex: 1;\n      margin-top: ${theme.spacing(1)};\n      gap: ${theme.spacing(0.5)};\n    `,\n    multiSelect: css`\n      & .scrollbar-view {\n        overscroll-behavior: contain;\n      }\n    `,\n  };\n}\n\nconst formatOptionLabel = memoizeOne(({ label, description }: SelectableValue<string>) => (\n  <Tooltip content={`${label}=\"${description}\"`} placement=\"top\" interactive={true}>\n    <span>{label}</span>\n  </Tooltip>\n));\n\nexport function LokiContextUi(props: LokiContextUiProps) {\n  const { row, languageProvider, updateFilter, onClose } = props;\n  const styles = useStyles2(getStyles);\n\n  const [contextFilters, setContextFilters] = useState<ContextFilter[]>([]);\n  const [initialized, setInitialized] = useState(false);\n  const timerHandle = React.useRef<number>();\n  const previousInitialized = React.useRef<boolean>(false);\n  useEffect(() => {\n    if (!initialized) {\n      return;\n    }\n\n    // don't trigger if we initialized, this will be the same query anyways.\n    if (!previousInitialized.current) {\n      previousInitialized.current = initialized;\n      return;\n    }\n\n    if (timerHandle.current) {\n      clearTimeout(timerHandle.current);\n    }\n    timerHandle.current = window.setTimeout(() => {\n      updateFilter(contextFilters);\n    }, 1500);\n\n    return () => {\n      clearTimeout(timerHandle.current);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contextFilters, initialized]);\n\n  useEffect(() => {\n    return () => {\n      clearTimeout(timerHandle.current);\n      onClose();\n    };\n  }, [onClose]);\n\n  useAsync(async () => {\n    await languageProvider.start();\n    const allLabels = languageProvider.getLabelKeys();\n    const contextFilters: ContextFilter[] = [];\n\n    Object.entries(row.labels).forEach(([label, value]) => {\n      const filter: ContextFilter = {\n        label,\n        value: label, // this looks weird in the first place, but we need to set the label as value here\n        enabled: allLabels.includes(label),\n        fromParser: !allLabels.includes(label),\n        description: value,\n      };\n      contextFilters.push(filter);\n    });\n\n    setContextFilters(contextFilters);\n    setInitialized(true);\n  });\n\n  useEffect(() => {\n    reportInteraction('grafana_explore_logs_loki_log_context_loaded', {\n      logRowUid: row.uid,\n      type: 'load',\n    });\n\n    return () => {\n      reportInteraction('grafana_explore_logs_loki_log_context_loaded', {\n        logRowUid: row.uid,\n        type: 'unload',\n      });\n    };\n  }, [row.uid]);\n\n  const realLabels = contextFilters.filter(({ fromParser }) => !fromParser);\n  const realLabelsEnabled = realLabels.filter(({ enabled }) => enabled);\n\n  const parsedLabels = contextFilters.filter(({ fromParser }) => fromParser);\n  const parsedLabelsEnabled = parsedLabels.filter(({ enabled }) => enabled);\n\n  return (\n    <div className={styles.multiSelectWrapper}>\n      <div>\n        {' '}\n        <Tooltip\n          content={\n            'This feature is experimental and only works on log queries containing no more than 1 parser (logfmt, json).'\n          }\n          placement=\"top\"\n        >\n          <Tag\n            className={css({\n              fontSize: 10,\n              padding: '1px 5px',\n              verticalAlign: 'text-bottom',\n            })}\n            name={'Experimental'}\n            colorIndex={1}\n          />\n        </Tooltip>{' '}\n        Select labels to include in the context query:\n      </div>\n      <div>\n        <MultiSelect\n          className={styles.multiSelect}\n          prefix=\"Labels\"\n          options={realLabels}\n          value={realLabelsEnabled}\n          formatOptionLabel={formatOptionLabel}\n          closeMenuOnSelect={true}\n          maxMenuHeight={200}\n          menuShouldPortal={false}\n          noOptionsMessage=\"No further labels available\"\n          onChange={(keys, actionMeta) => {\n            if (actionMeta.action === 'select-option') {\n              reportInteraction('grafana_explore_logs_loki_log_context_filtered', {\n                logRowUid: row.uid,\n                type: 'label',\n                action: 'select',\n              });\n            }\n            if (actionMeta.action === 'remove-value') {\n              reportInteraction('grafana_explore_logs_loki_log_context_filtered', {\n                logRowUid: row.uid,\n                type: 'label',\n                action: 'remove',\n              });\n            }\n            return setContextFilters(\n              contextFilters.map((filter) => {\n                if (filter.fromParser) {\n                  return filter;\n                }\n                filter.enabled = keys.some((key) => key.value === filter.value);\n                return filter;\n              })\n            );\n          }}\n        />\n      </div>\n      {parsedLabels.length > 0 && (\n        <div>\n          <MultiSelect\n            className={styles.multiSelect}\n            prefix=\"Parsed Labels\"\n            options={parsedLabels}\n            value={parsedLabelsEnabled}\n            formatOptionLabel={formatOptionLabel}\n            closeMenuOnSelect={true}\n            menuShouldPortal={false}\n            maxMenuHeight={200}\n            noOptionsMessage=\"No further labels available\"\n            isClearable={true}\n            onChange={(keys, actionMeta) => {\n              if (actionMeta.action === 'select-option') {\n                reportInteraction('grafana_explore_logs_loki_log_context_filtered', {\n                  logRowUid: row.uid,\n                  type: 'parsed_label',\n                  action: 'select',\n                });\n              }\n              if (actionMeta.action === 'remove-value') {\n                reportInteraction('grafana_explore_logs_loki_log_context_filtered', {\n                  logRowUid: row.uid,\n                  type: 'parsed_label',\n                  action: 'remove',\n                });\n              }\n              setContextFilters(\n                contextFilters.map((filter) => {\n                  if (!filter.fromParser) {\n                    return filter;\n                  }\n                  filter.enabled = keys.some((key) => key.value === filter.value);\n                  return filter;\n                })\n              );\n            }}\n          />\n        </div>\n      )}\n    </div>\n  );\n}\n","import { LokiVariableQuery, LokiVariableQueryType } from '../types';\n\nexport const labelNamesRegex = /^label_names\\(\\)\\s*$/;\nexport const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\nexport function migrateVariableQuery(rawQuery: string | LokiVariableQuery): LokiVariableQuery {\n  // If not string, we assume LokiVariableQuery\n  if (typeof rawQuery !== 'string') {\n    return rawQuery;\n  }\n\n  const queryBase = {\n    refId: 'LokiVariableQueryEditor-VariableQuery',\n    type: LokiVariableQueryType.LabelNames,\n  };\n\n  const labelNames = rawQuery.match(labelNamesRegex);\n  if (labelNames) {\n    return {\n      ...queryBase,\n      type: LokiVariableQueryType.LabelNames,\n    };\n  }\n\n  const labelValues = rawQuery.match(labelValuesRegex);\n  if (labelValues) {\n    return {\n      ...queryBase,\n      type: LokiVariableQueryType.LabelValues,\n      label: labelValues[2] ? labelValues[2] : labelValues[1],\n      stream: labelValues[2] ? labelValues[1] : undefined,\n    };\n  }\n\n  return queryBase;\n}\n","import { DataFrame, QueryHint } from '@grafana/data';\n\nimport {\n  isQueryWithLabelFilter,\n  isQueryPipelineErrorFiltering,\n  isQueryWithLabelFormat,\n  isQueryWithParser,\n  isQueryWithLineFilter,\n} from './queryUtils';\nimport {\n  dataFrameHasLevelLabel,\n  extractHasErrorLabelFromDataFrame,\n  extractLevelLikeLabelFromDataFrame,\n  extractLogParserFromDataFrame,\n} from './responseUtils';\n\nexport function getQueryHints(query: string, series: DataFrame[]): QueryHint[] {\n  if (series.length === 0) {\n    return [];\n  }\n\n  const hints: QueryHint[] = [];\n  const { queryWithParser, parserCount } = isQueryWithParser(query);\n\n  if (!queryWithParser) {\n    const { hasLogfmt, hasJSON } = extractLogParserFromDataFrame(series[0]);\n    if (hasJSON) {\n      hints.push({\n        type: 'ADD_JSON_PARSER',\n        label: 'Selected log stream selector has JSON formatted logs.',\n        fix: {\n          title: 'add json parser',\n          label: 'Consider using JSON parser.',\n          action: {\n            type: 'ADD_JSON_PARSER',\n            query,\n          },\n        },\n      });\n    }\n\n    if (hasLogfmt) {\n      hints.push({\n        type: 'ADD_LOGFMT_PARSER',\n        label: 'Selected log stream selector has logfmt formatted logs.',\n        fix: {\n          title: 'add logfmt parser',\n          label: 'Consider using logfmt parser to turn key-value pairs in your log lines to labels.',\n          action: {\n            type: 'ADD_LOGFMT_PARSER',\n            query,\n          },\n        },\n      });\n    }\n  }\n\n  if (queryWithParser) {\n    // To keep this simple, we consider pipeline error filtering hint only is query has up to 1 parser\n    if (parserCount === 1) {\n      const hasPipelineErrorFiltering = isQueryPipelineErrorFiltering(query);\n      const hasError = extractHasErrorLabelFromDataFrame(series[0]);\n      if (hasError && !hasPipelineErrorFiltering) {\n        hints.push({\n          type: 'ADD_NO_PIPELINE_ERROR',\n          label: 'Some logs in your selected log streams have parsing error.',\n          fix: {\n            title: 'remove pipeline errors',\n            label: 'Consider filtering out logs with parsing errors.',\n            action: {\n              type: 'ADD_NO_PIPELINE_ERROR',\n              query,\n            },\n          },\n        });\n      }\n    }\n\n    const hasLabelFilter = isQueryWithLabelFilter(query);\n\n    if (!hasLabelFilter) {\n      hints.push({\n        type: 'ADD_LABEL_FILTER',\n        label: 'Consider filtering logs by their label and value.',\n        fix: {\n          title: 'add label filter',\n          label: '',\n          action: {\n            type: 'ADD_LABEL_FILTER',\n            query,\n          },\n        },\n      });\n    }\n  }\n\n  const queryWithLabelFormat = isQueryWithLabelFormat(query);\n  if (!queryWithLabelFormat) {\n    const hasLevel = dataFrameHasLevelLabel(series[0]);\n    const levelLikeLabel = extractLevelLikeLabelFromDataFrame(series[0]);\n\n    // Add hint only if we don't have \"level\" label and have level-like label\n    if (!hasLevel && levelLikeLabel) {\n      hints.push({\n        type: 'ADD_LEVEL_LABEL_FORMAT',\n        label: `Some logs in your selected log stream have \"${levelLikeLabel}\" label.`,\n        fix: {\n          title: 'add label level format',\n          label: `If ${levelLikeLabel} label has level values, consider using label_format to rename it to \"level\". Level label can be then visualized in log volumes.`,\n          action: {\n            type: 'ADD_LEVEL_LABEL_FORMAT',\n            query,\n            options: {\n              renameTo: 'level',\n              originalLabel: levelLikeLabel,\n            },\n          },\n        },\n      });\n    }\n  }\n\n  const hasLineFilter = isQueryWithLineFilter(query);\n\n  if (!hasLineFilter) {\n    hints.push({\n      type: 'ADD_LINE_FILTER',\n      label: 'Consider filtering logs for specific string.',\n      fix: {\n        title: 'add line filter',\n        label: '',\n        action: {\n          type: 'ADD_LINE_FILTER',\n          query,\n        },\n      },\n    });\n  }\n\n  return hints;\n}\n","import { DataFrame, Field, SortedVector } from '@grafana/data';\n\ntype SortDirection = 'ASCENDING' | 'DESCENDING';\n\n// creates the `index` for the sorting.\n// this is needed by the `SortedVector`.\n// the index is an array of numbers, and it defines an order.\n// at every slot in the index the values is the position of\n// the sorted item.\n// for example, an index of [3,1,2] means that\n// in the dataframe, that has 3 rows, after sorting:\n// - the third row will become the first\n// - the first row will become the second\n// - the second row will become the third\nfunction makeIndex(field: Field<string>, dir: SortDirection): number[] {\n  const fieldValues: string[] = field.values.toArray();\n\n  // we first build an array which is [0,1,2,3....]\n  const index = Array(fieldValues.length);\n  for (let i = 0; i < index.length; i++) {\n    index[i] = i;\n  }\n\n  const isAsc = dir === 'ASCENDING';\n\n  index.sort((a: number, b: number): number => {\n    // we need to answer this question:\n    // in the field-used-for-sorting, how would we compare value-at-index-a to value-at-index-b?\n    const valA = fieldValues[a];\n    const valB = fieldValues[b];\n    if (valA < valB) {\n      return isAsc ? -1 : 1;\n    }\n\n    if (valA > valB) {\n      return isAsc ? 1 : -1;\n    }\n\n    return 0;\n  });\n\n  return index;\n}\n\n// sort a dataframe that is in the Loki format ascending or descending,\n// based on the nanosecond-timestamp\nexport function sortDataFrameByTime(frame: DataFrame, dir: SortDirection): DataFrame {\n  const { fields, ...rest } = frame;\n\n  // we use the approach used in @grafana/data/sortDataframe.\n  // we cannot use it directly, because our tsNs field has a type=time,\n  // so we have to build the `index` manually.\n\n  const tsNsField = fields.find((field) => field.name === 'tsNs');\n  if (tsNsField === undefined) {\n    throw new Error('missing nanosecond-timestamp field. should never happen');\n  }\n\n  const index = makeIndex(tsNsField, dir);\n\n  return {\n    ...rest,\n    fields: fields.map((field) => ({\n      ...field,\n      values: new SortedVector(field.values, index),\n    })),\n  };\n\n  return frame;\n}\n","import { map, Observable, defer, mergeMap } from 'rxjs';\n\nimport { DataFrameJSON, DataQueryRequest, DataQueryResponse, LiveChannelScope, LoadingState } from '@grafana/data';\nimport { getGrafanaLiveSrv } from '@grafana/runtime';\nimport { StreamingDataFrame } from 'app/features/live/data/StreamingDataFrame';\n\nimport { LokiDatasource } from './datasource';\nimport { LokiQuery } from './types';\n\n/**\n * Calculate a unique key for the query.  The key is used to pick a channel and should\n * be unique for each distinct query execution plan.  This key is not secure and is only picked to avoid\n * possible collisions\n */\nexport async function getLiveStreamKey(query: LokiQuery): Promise<string> {\n  const str = JSON.stringify({ expr: query.expr });\n\n  const msgUint8 = new TextEncoder().encode(str); // encode as (utf-8) Uint8Array\n  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message\n  const hashArray = Array.from(new Uint8Array(hashBuffer.slice(0, 8))); // first 8 bytes\n  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n}\n\n// This will get both v1 and v2 result formats\nexport function doLokiChannelStream(\n  query: LokiQuery,\n  ds: LokiDatasource,\n  options: DataQueryRequest<LokiQuery>\n): Observable<DataQueryResponse> {\n  // maximum time to keep values\n  const range = options.range;\n  const maxDelta = range.to.valueOf() - range.from.valueOf() + 1000;\n  let maxLength = options.maxDataPoints ?? 1000;\n  if (maxLength > 100) {\n    // for small buffers, keep them small\n    maxLength *= 2;\n  }\n\n  let frame: StreamingDataFrame | undefined = undefined;\n  const updateFrame = (msg: any) => {\n    if (msg?.message) {\n      const p = msg.message as DataFrameJSON;\n      if (!frame) {\n        frame = StreamingDataFrame.fromDataFrameJSON(p, {\n          maxLength,\n          maxDelta,\n          displayNameFormat: query.legendFormat,\n        });\n      } else {\n        frame.push(p);\n      }\n    }\n    return frame;\n  };\n\n  return defer(() => getLiveStreamKey(query)).pipe(\n    mergeMap((key) => {\n      return getGrafanaLiveSrv()\n        .getStream<any>({\n          scope: LiveChannelScope.DataSource,\n          namespace: ds.uid,\n          path: `tail/${key}`,\n          data: {\n            ...query,\n            timeRange: {\n              from: range.from.valueOf().toString(),\n              to: range.to.valueOf().toString(),\n            },\n          },\n        })\n        .pipe(\n          map((evt) => {\n            const frame = updateFrame(evt);\n            return {\n              data: frame ? [frame] : [],\n              state: LoadingState.Streaming,\n            };\n          })\n        );\n    })\n  );\n}\n","import React, { FC, FormEvent, useState, useEffect } from 'react';\n\nimport { QueryEditorProps, SelectableValue } from '@grafana/data';\nimport { InlineField, InlineFieldRow, Input, Select } from '@grafana/ui';\n\nimport { LokiDatasource } from '../datasource';\nimport { migrateVariableQuery } from '../migrations/variableQueryMigrations';\nimport { LokiOptions, LokiQuery, LokiVariableQuery, LokiVariableQueryType as QueryType } from '../types';\n\nconst variableOptions = [\n  { label: 'Label names', value: QueryType.LabelNames },\n  { label: 'Label values', value: QueryType.LabelValues },\n];\n\nexport type Props = QueryEditorProps<LokiDatasource, LokiQuery, LokiOptions, LokiVariableQuery>;\n\nconst refId = 'LokiVariableQueryEditor-VariableQuery';\n\nexport const LokiVariableQueryEditor: FC<Props> = ({ onChange, query, datasource }) => {\n  const [type, setType] = useState<number | undefined>(undefined);\n  const [label, setLabel] = useState('');\n  const [labelOptions, setLabelOptions] = useState<Array<SelectableValue<string>>>([]);\n  const [stream, setStream] = useState('');\n\n  useEffect(() => {\n    if (!query) {\n      return;\n    }\n\n    const variableQuery = typeof query === 'string' ? migrateVariableQuery(query) : query;\n    setType(variableQuery.type);\n    setLabel(variableQuery.label || '');\n    setStream(variableQuery.stream || '');\n\n    if (variableQuery.label) {\n      setLabelOptions([{ label: variableQuery.label, value: variableQuery.label }]);\n    }\n  }, [query]);\n\n  useEffect(() => {\n    if (type !== QueryType.LabelValues) {\n      return;\n    }\n\n    datasource.labelNamesQuery().then((labelNames: Array<{ text: string }>) => {\n      setLabelOptions(labelNames.map(({ text }) => ({ label: text, value: text })));\n    });\n  }, [datasource, type]);\n\n  const onQueryTypeChange = (newType: SelectableValue<QueryType>) => {\n    setType(newType.value);\n    if (newType.value !== undefined) {\n      onChange({\n        type: newType.value,\n        label,\n        stream,\n        refId,\n      });\n    }\n  };\n\n  const onLabelChange = (newLabel: SelectableValue<string>) => {\n    setLabel(newLabel.value || '');\n  };\n\n  const onStreamChange = (e: FormEvent<HTMLInputElement>) => {\n    setStream(e.currentTarget.value);\n  };\n\n  const handleBlur = () => {\n    if (type !== undefined) {\n      onChange({ type, label, stream, refId: 'LokiVariableQueryEditor-VariableQuery' });\n    }\n  };\n\n  return (\n    <InlineFieldRow>\n      <InlineField label=\"Query type\" labelWidth={20}>\n        <Select\n          aria-label=\"Query type\"\n          onChange={onQueryTypeChange}\n          onBlur={handleBlur}\n          value={type}\n          options={variableOptions}\n          width={16}\n        />\n      </InlineField>\n      {type === QueryType.LabelValues && (\n        <>\n          <InlineField label=\"Label\" labelWidth={20}>\n            <Select\n              aria-label=\"Label\"\n              onChange={onLabelChange}\n              onBlur={handleBlur}\n              value={label}\n              options={labelOptions}\n              width={16}\n              allowCustomValue\n            />\n          </InlineField>\n          <InlineField\n            label=\"Stream selector\"\n            labelWidth={20}\n            tooltip={\n              <div>\n                {\n                  'Optional. If defined, a list of values for the specified log stream selector is returned. For example: {label=\"value\"} or {label=\"$variable\"}'\n                }\n              </div>\n            }\n          >\n            <Input\n              type=\"text\"\n              aria-label=\"Stream selector\"\n              placeholder=\"Optional stream selector\"\n              value={stream}\n              onChange={onStreamChange}\n              onBlur={handleBlur}\n              width={22}\n            />\n          </InlineField>\n        </>\n      )}\n    </InlineFieldRow>\n  );\n};\n","import { from, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { CustomVariableSupport, DataQueryRequest, DataQueryResponse } from '@grafana/data';\n\nimport { LokiVariableQueryEditor } from './components/VariableQueryEditor';\nimport { LokiDatasource } from './datasource';\nimport { LokiVariableQuery } from './types';\n\nexport class LokiVariableSupport extends CustomVariableSupport<LokiDatasource, LokiVariableQuery> {\n  editor = LokiVariableQueryEditor;\n\n  constructor(private datasource: LokiDatasource) {\n    super();\n    this.query = this.query.bind(this);\n  }\n\n  async execute(query: LokiVariableQuery) {\n    return this.datasource.metricFindQuery(query);\n  }\n\n  query(request: DataQueryRequest<LokiVariableQuery>): Observable<DataQueryResponse> {\n    const result = this.execute(request.targets[0]);\n\n    return from(result).pipe(map((data) => ({ data })));\n  }\n}\n","import { cloneDeep, map as lodashMap } from 'lodash';\nimport { lastValueFrom, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap, tap } from 'rxjs/operators';\n\nimport {\n  AbstractQuery,\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  CoreApp,\n  DataFrame,\n  DataFrameView,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  DataSourceWithSupplementaryQueriesSupport,\n  SupplementaryQueryType,\n  DataSourceWithQueryExportSupport,\n  DataSourceWithQueryImportSupport,\n  dateMath,\n  DateTime,\n  FieldCache,\n  FieldType,\n  getDefaultTimeRange,\n  Labels,\n  LoadingState,\n  LogLevel,\n  LogRowModel,\n  QueryFixAction,\n  QueryHint,\n  rangeUtil,\n  ScopedVars,\n  TimeRange,\n  toUtc,\n} from '@grafana/data';\nimport { BackendSrvRequest, config, DataSourceWithBackend, FetchError } from '@grafana/runtime';\nimport { DataQuery } from '@grafana/schema';\nimport { queryLogsSample, queryLogsVolume } from 'app/core/logsModel';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { RowContextOptions } from '../../../features/logs/components/LogRowContextProvider';\nimport { getLogLevelFromKey } from '../../../features/logs/utils';\nimport { renderLegendFormat } from '../prometheus/legend';\nimport { replaceVariables, returnVariables } from '../prometheus/querybuilder/shared/parsingUtils';\n\nimport LanguageProvider from './LanguageProvider';\nimport { LiveStreams, LokiLiveTarget } from './LiveStreams';\nimport { transformBackendResult } from './backendResultTransformer';\nimport { LokiAnnotationsQueryEditor } from './components/AnnotationsQueryEditor';\nimport { LokiContextUi } from './components/LokiContextUi';\nimport { escapeLabelValueInExactSelector, escapeLabelValueInSelector, isRegexSelector } from './languageUtils';\nimport { labelNamesRegex, labelValuesRegex } from './migrations/variableQueryMigrations';\nimport {\n  addLabelFormatToQuery,\n  addLabelToQuery,\n  addNoPipelineErrorToQuery,\n  addParserToQuery,\n  removeCommentsFromQuery,\n  addFilterAsLabelFilter,\n  getParserPositions,\n  toLabelFilter,\n  addLineFilter,\n  findLastPosition,\n  getLabelFilterPositions,\n} from './modifyQuery';\nimport { getQueryHints } from './queryHints';\nimport {\n  getLogQueryFromMetricsQuery,\n  getNormalizedLokiQuery,\n  getStreamSelectorsFromQuery,\n  getParserFromQuery,\n  isLogsQuery,\n  isValidQuery,\n} from './queryUtils';\nimport { sortDataFrameByTime } from './sortDataFrame';\nimport { doLokiChannelStream } from './streaming';\nimport { trackQuery } from './tracking';\nimport {\n  ContextFilter,\n  LokiOptions,\n  LokiQuery,\n  LokiQueryDirection,\n  LokiQueryType,\n  LokiVariableQuery,\n  LokiVariableQueryType,\n  QueryStats,\n  SupportingQueryType,\n} from './types';\nimport { LokiVariableSupport } from './variables';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nexport const REF_ID_DATA_SAMPLES = 'loki-data-samples';\nexport const REF_ID_STARTER_ANNOTATION = 'annotation-';\nexport const REF_ID_STARTER_LOG_ROW_CONTEXT = 'log-row-context-query-';\nexport const REF_ID_STARTER_LOG_VOLUME = 'log-volume-';\nexport const REF_ID_STARTER_LOG_SAMPLE = 'log-sample-';\nconst NS_IN_MS = 1000000;\n\nfunction makeRequest(\n  query: LokiQuery,\n  range: TimeRange,\n  app: CoreApp,\n  requestId: string,\n  hideFromInspector?: boolean\n): DataQueryRequest<LokiQuery> {\n  const intervalInfo = rangeUtil.calculateInterval(range, 1);\n  return {\n    targets: [query],\n    requestId,\n    interval: intervalInfo.interval,\n    intervalMs: intervalInfo.intervalMs,\n    range: range,\n    scopedVars: {},\n    timezone: 'UTC',\n    app,\n    startTime: Date.now(),\n    hideFromInspector,\n  };\n}\n\nexport class LokiDatasource\n  extends DataSourceWithBackend<LokiQuery, LokiOptions>\n  implements\n    DataSourceWithLogsContextSupport,\n    DataSourceWithSupplementaryQueriesSupport<LokiQuery>,\n    DataSourceWithQueryImportSupport<LokiQuery>,\n    DataSourceWithQueryExportSupport<LokiQuery>\n{\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n    this.annotations = {\n      QueryEditor: LokiAnnotationsQueryEditor,\n    };\n    this.variables = new LokiVariableSupport(this);\n  }\n\n  getDataProvider(\n    type: SupplementaryQueryType,\n    request: DataQueryRequest<LokiQuery>\n  ): Observable<DataQueryResponse> | undefined {\n    if (!this.getSupportedSupplementaryQueryTypes().includes(type)) {\n      return undefined;\n    }\n    switch (type) {\n      case SupplementaryQueryType.LogsVolume:\n        return this.getLogsVolumeDataProvider(request);\n      case SupplementaryQueryType.LogsSample:\n        return this.getLogsSampleDataProvider(request);\n      default:\n        return undefined;\n    }\n  }\n\n  getSupportedSupplementaryQueryTypes(): SupplementaryQueryType[] {\n    return [SupplementaryQueryType.LogsVolume, SupplementaryQueryType.LogsSample];\n  }\n\n  getSupplementaryQuery(type: SupplementaryQueryType, query: LokiQuery): LokiQuery | undefined {\n    if (!this.getSupportedSupplementaryQueryTypes().includes(type)) {\n      return undefined;\n    }\n\n    const normalizedQuery = getNormalizedLokiQuery(query);\n    const expr = removeCommentsFromQuery(normalizedQuery.expr);\n    let isQuerySuitable = false;\n\n    switch (type) {\n      case SupplementaryQueryType.LogsVolume:\n        // it has to be a logs-producing range-query\n        isQuerySuitable = !!(query.expr && isLogsQuery(query.expr) && query.queryType === LokiQueryType.Range);\n        if (!isQuerySuitable) {\n          return undefined;\n        }\n\n        return {\n          ...normalizedQuery,\n          refId: `${REF_ID_STARTER_LOG_VOLUME}${normalizedQuery.refId}`,\n          instant: false,\n          supportingQueryType: SupportingQueryType.LogsVolume,\n          expr: `sum by (level) (count_over_time(${expr}[$__interval]))`,\n        };\n\n      case SupplementaryQueryType.LogsSample:\n        // it has to be a metric query\n        isQuerySuitable = !!(query.expr && !isLogsQuery(query.expr));\n        if (!isQuerySuitable) {\n          return undefined;\n        }\n        return {\n          ...normalizedQuery,\n          refId: `${REF_ID_STARTER_LOG_SAMPLE}${normalizedQuery.refId}`,\n          expr: getLogQueryFromMetricsQuery(expr),\n          maxLines: 100,\n        };\n\n      default:\n        return undefined;\n    }\n  }\n\n  getLogsVolumeDataProvider(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> | undefined {\n    const logsVolumeRequest = cloneDeep(request);\n    const targets = logsVolumeRequest.targets\n      .map((query) => this.getSupplementaryQuery(SupplementaryQueryType.LogsVolume, query))\n      .filter((query): query is LokiQuery => !!query);\n\n    if (!targets.length) {\n      return undefined;\n    }\n\n    return queryLogsVolume(\n      this,\n      { ...logsVolumeRequest, targets },\n      {\n        extractLevel,\n        range: request.range,\n        targets: request.targets,\n      }\n    );\n  }\n\n  getLogsSampleDataProvider(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> | undefined {\n    const logsSampleRequest = cloneDeep(request);\n    const targets = logsSampleRequest.targets\n      .map((query) => this.getSupplementaryQuery(SupplementaryQueryType.LogsSample, query))\n      .filter((query): query is LokiQuery => !!query);\n\n    if (!targets.length) {\n      return undefined;\n    }\n    return queryLogsSample(this, { ...logsSampleRequest, targets });\n  }\n\n  query(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const queries = request.targets\n      .map(getNormalizedLokiQuery) // \"fix\" the `.queryType` prop\n      .map((q) => ({ ...q, maxLines: q.maxLines ?? this.maxLines }));\n\n    const fixedRequest: DataQueryRequest<LokiQuery> & { targets: LokiQuery[] } = {\n      ...request,\n      targets: queries,\n    };\n\n    const streamQueries = fixedRequest.targets.filter((q) => q.queryType === LokiQueryType.Stream);\n    if (config.featureToggles.lokiLive && streamQueries.length > 0 && fixedRequest.rangeRaw?.to === 'now') {\n      // this is still an in-development feature,\n      // we do not support mixing stream-queries with normal-queries for now.\n      const streamRequest = {\n        ...fixedRequest,\n        targets: streamQueries,\n      };\n      return merge(\n        ...streamQueries.map((q) =>\n          doLokiChannelStream(\n            this.applyTemplateVariables(q, request.scopedVars),\n            this, // the datasource\n            streamRequest\n          )\n        )\n      );\n    }\n\n    if (fixedRequest.liveStreaming) {\n      return this.runLiveQueryThroughBackend(fixedRequest);\n    } else {\n      const startTime = new Date();\n      return super.query(fixedRequest).pipe(\n        // in case of an empty query, this is somehow run twice. `share()` is no workaround here as the observable is generated from `of()`.\n        map((response) =>\n          transformBackendResult(response, fixedRequest.targets, this.instanceSettings.jsonData.derivedFields ?? [])\n        ),\n        tap((response) => trackQuery(response, fixedRequest, startTime))\n      );\n    }\n  }\n\n  runLiveQueryThroughBackend(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    // this only works in explore-mode, so variables don't need to be handled,\n    //  and only for logs-queries, not metric queries\n    const logsQueries = request.targets.filter((query) => query.expr !== '' && isLogsQuery(query.expr));\n\n    if (logsQueries.length === 0) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    const subQueries = logsQueries.map((query) => {\n      const maxDataPoints = query.maxLines || this.maxLines;\n      // FIXME: currently we are running it through the frontend still.\n      return this.runLiveQuery(query, maxDataPoints);\n    });\n\n    return merge(...subQueries);\n  }\n\n  createLiveTarget(target: LokiQuery, maxDataPoints: number): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints,\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, maxDataPoints: number): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, maxDataPoints);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map((data) => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      })),\n      catchError((err: any) => {\n        return throwError(() => `Live tailing was stopped due to following error: ${err.reason}`);\n      })\n    );\n  };\n\n  getRangeScopedVars(range: TimeRange = this.getTimeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => ({\n        ...query,\n        datasource: this.getRef(),\n        expr: this.addAdHocFilters(this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr)),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  getTimeRange() {\n    return this.timeSrv.timeRange();\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.getTimeRange();\n    return { start: timeRange.from.valueOf() * NS_IN_MS, end: timeRange.to.valueOf() * NS_IN_MS };\n  }\n\n  async importFromAbstractQueries(abstractQueries: AbstractQuery[]): Promise<LokiQuery[]> {\n    await this.languageProvider.start();\n    const existingKeys = this.languageProvider.labelKeys;\n\n    if (existingKeys && existingKeys.length) {\n      abstractQueries = abstractQueries.map((abstractQuery) => {\n        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter((labelMatcher) => {\n          return existingKeys.includes(labelMatcher.name);\n        });\n        return abstractQuery;\n      });\n    }\n\n    return abstractQueries.map((abstractQuery) => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  async exportToAbstractQueries(queries: LokiQuery[]): Promise<AbstractQuery[]> {\n    return queries.map((query) => this.languageProvider.exportToAbstractQuery(query));\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>, options?: Partial<BackendSrvRequest>) {\n    // url must not start with a `/`, otherwise the AJAX-request\n    // going from the browser will contain `//`, which can cause problems.\n    if (url.startsWith('/')) {\n      throw new Error(`invalid metadata request url: ${url}`);\n    }\n\n    const res = await this.getResource(url, params, options);\n    return res.data ?? (res || []);\n  }\n\n  async getQueryStats(query: LokiQuery): Promise<QueryStats> {\n    const { start, end } = this.getTimeRangeParams();\n    const labelMatchers = getStreamSelectorsFromQuery(query.expr);\n\n    let statsForAll: QueryStats = { streams: 0, chunks: 0, bytes: 0, entries: 0 };\n\n    for (const labelMatcher of labelMatchers) {\n      try {\n        const data = await this.metadataRequest(\n          'index/stats',\n          { query: labelMatcher, start, end },\n          { showErrorAlert: false }\n        );\n\n        statsForAll = {\n          streams: statsForAll.streams + data.streams,\n          chunks: statsForAll.chunks + data.chunks,\n          bytes: statsForAll.bytes + data.bytes,\n          entries: statsForAll.entries + data.entries,\n        };\n      } catch (e) {\n        break;\n      }\n    }\n\n    return statsForAll;\n  }\n\n  async metricFindQuery(query: LokiVariableQuery | string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    if (typeof query === 'string') {\n      const interpolated = this.interpolateString(query);\n      return await this.legacyProcessMetricFindQuery(interpolated);\n    }\n\n    const interpolatedQuery = {\n      ...query,\n      label: this.interpolateString(query.label || ''),\n      stream: this.interpolateString(query.stream || ''),\n    };\n\n    return await this.processMetricFindQuery(interpolatedQuery);\n  }\n\n  async processMetricFindQuery(query: LokiVariableQuery) {\n    if (query.type === LokiVariableQueryType.LabelNames) {\n      return this.labelNamesQuery();\n    }\n\n    if (!query.label) {\n      return [];\n    }\n\n    // If we have stream selector, use /series endpoint\n    if (query.stream) {\n      return this.labelValuesSeriesQuery(query.stream, query.label);\n    }\n\n    return this.labelValuesQuery(query.label);\n  }\n\n  async legacyProcessMetricFindQuery(query: string) {\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      // If we have stream selector, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = 'labels';\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string) {\n    const params = this.getTimeRangeParams();\n    const url = `label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesSeriesQuery(expr: string, label: string) {\n    const timeParams = this.getTimeRangeParams();\n    const params = {\n      ...timeParams,\n      'match[]': expr,\n    };\n    const url = 'series';\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach((stream: { [key: string]: string }) => {\n      if (stream[label]) {\n        streams.add({ text: stream[label] });\n      }\n    });\n\n    return Array.from(streams);\n  }\n\n  async getDataSamples(query: LokiQuery): Promise<DataFrame[]> {\n    // Currently works only for logs sample\n    if (!isValidQuery(query.expr) || !isLogsQuery(query.expr)) {\n      return [];\n    }\n\n    const lokiLogsQuery: LokiQuery = {\n      expr: query.expr,\n      queryType: LokiQueryType.Range,\n      refId: REF_ID_DATA_SAMPLES,\n      maxLines: 10,\n    };\n\n    // For samples, we use defaultTimeRange (now-6h/now) and limit od 10 lines so queries are small and fast\n    const timeRange = getDefaultTimeRange();\n    const request = makeRequest(lokiLogsQuery, timeRange, CoreApp.Unknown, REF_ID_DATA_SAMPLES, true);\n    return await lastValueFrom(this.query(request).pipe(switchMap((res) => of(res.data))));\n  }\n\n  // By implementing getTagKeys and getTagValues we add ad-hoc filters functionality\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options: any = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: QueryFixAction): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        if (action.options?.key && action.options?.value) {\n          const value = escapeLabelValueInSelector(action.options.value);\n          expression = addLabelToQuery(expression, action.options.key, '=', value);\n        }\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        if (action.options?.key && action.options?.value) {\n          const value = escapeLabelValueInSelector(action.options.value);\n          expression = addLabelToQuery(expression, action.options.key, '!=', value);\n        }\n        break;\n      }\n      case 'ADD_LOGFMT_PARSER': {\n        expression = addParserToQuery(expression, 'logfmt');\n        break;\n      }\n      case 'ADD_JSON_PARSER': {\n        expression = addParserToQuery(expression, 'json');\n        break;\n      }\n      case 'ADD_NO_PIPELINE_ERROR': {\n        expression = addNoPipelineErrorToQuery(expression);\n        break;\n      }\n      case 'ADD_LEVEL_LABEL_FORMAT': {\n        if (action.options?.originalLabel && action.options?.renameTo) {\n          expression = addLabelFormatToQuery(expression, {\n            renameTo: action.options.renameTo,\n            originalLabel: action.options.originalLabel,\n          });\n        }\n        break;\n      }\n      case 'ADD_LABEL_FILTER': {\n        const parserPositions = getParserPositions(query.expr);\n        const labelFilterPositions = getLabelFilterPositions(query.expr);\n        const lastPosition = findLastPosition([...parserPositions, ...labelFilterPositions]);\n        const filter = toLabelFilter('', '', '=');\n        expression = addFilterAsLabelFilter(expression, [lastPosition], filter);\n        break;\n      }\n      case 'ADD_LINE_FILTER': {\n        expression = addLineFilter(expression);\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = async (\n    row: LogRowModel,\n    options?: RowContextOptions,\n    origQuery?: DataQuery\n  ): Promise<{ data: DataFrame[] }> => {\n    const direction = (options && options.direction) || 'BACKWARD';\n    const limit = (options && options.limit) || 10;\n    const { query, range } = await this.prepareLogRowContextQueryTarget(row, limit, direction, origQuery);\n\n    const processDataFrame = (frame: DataFrame): DataFrame => {\n      // log-row-context requires specific field-names to work, so we set them here: \"ts\", \"line\", \"id\"\n      const cache = new FieldCache(frame);\n      const timestampField = cache.getFirstFieldOfType(FieldType.time);\n      const lineField = cache.getFirstFieldOfType(FieldType.string);\n      const idField = cache.getFieldByName('id');\n\n      if (timestampField === undefined || lineField === undefined || idField === undefined) {\n        // this should never really happen, but i want to keep typescript happy\n        return { ...frame, fields: [] };\n      }\n\n      return {\n        ...frame,\n        fields: [\n          {\n            ...timestampField,\n            name: 'ts',\n          },\n          {\n            ...lineField,\n            name: 'line',\n          },\n          {\n            ...idField,\n            name: 'id',\n          },\n        ],\n      };\n    };\n\n    const processResults = (result: DataQueryResponse): DataQueryResponse => {\n      const frames: DataFrame[] = result.data;\n      const processedFrames = frames\n        .map((frame) => sortDataFrameByTime(frame, 'DESCENDING'))\n        .map((frame) => processDataFrame(frame)); // rename fields if needed\n\n      return {\n        ...result,\n        data: processedFrames,\n      };\n    };\n\n    // this can only be called from explore currently\n    const app = CoreApp.Explore;\n\n    return lastValueFrom(\n      this.query(makeRequest(query, range, app, `${REF_ID_STARTER_LOG_ROW_CONTEXT}${direction}`)).pipe(\n        catchError((err) => {\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res) => of(processResults(res)))\n      )\n    );\n  };\n\n  prepareLogRowContextQueryTarget = async (\n    row: LogRowModel,\n    limit: number,\n    direction: 'BACKWARD' | 'FORWARD',\n    origQuery?: DataQuery\n  ): Promise<{ query: LokiQuery; range: TimeRange }> => {\n    let expr = await this.prepareContextExpr(row, origQuery);\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n\n    const queryDirection = direction === 'FORWARD' ? LokiQueryDirection.Forward : LokiQueryDirection.Backward;\n\n    const query: LokiQuery = {\n      expr,\n      queryType: LokiQueryType.Range,\n      refId: `${REF_ID_STARTER_LOG_ROW_CONTEXT}${row.dataFrame.refId || ''}`,\n      maxLines: limit,\n      direction: queryDirection,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const tsField = fieldCache.getFirstFieldOfType(FieldType.time);\n    if (tsField === undefined) {\n      throw new Error('loki: dataframe missing time-field, should never happen');\n    }\n    const tsValue = tsField.values.get(row.rowIndex);\n    const timestamp = toUtc(tsValue);\n\n    const range =\n      queryDirection === LokiQueryDirection.Forward\n        ? {\n            // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n            // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n            // because the are before but came it he response that should return only rows after.\n            from: timestamp,\n            // convert to ns, we lose some precision here but it is not that important at the far points of the context\n            to: toUtc(row.timeEpochMs + contextTimeBuffer),\n          }\n        : {\n            // convert to ns, we lose some precision here but it is not that important at the far points of the context\n            from: toUtc(row.timeEpochMs - contextTimeBuffer),\n            to: timestamp,\n          };\n\n    return {\n      query,\n      range: {\n        from: range.from,\n        to: range.to,\n        raw: range,\n      },\n    };\n  };\n\n  async prepareContextExprWithoutParsedLabels(row: LogRowModel, origQuery?: DataQuery): Promise<string> {\n    await this.languageProvider.start();\n    const labels = this.languageProvider.getLabelKeys();\n    const expr = Object.keys(row.labels)\n      .map((label: string) => {\n        if (labels.includes(label)) {\n          // escape backslashes in label as users can't escape them by themselves\n          return `${label}=\"${escapeLabelValueInExactSelector(row.labels[label])}\"`;\n        }\n        return '';\n      })\n      .filter((label) => !!label)\n      .join(',');\n\n    return `{${expr}}`;\n  }\n\n  async prepareContextExpr(row: LogRowModel, origQuery?: DataQuery): Promise<string> {\n    return await this.prepareContextExprWithoutParsedLabels(row, origQuery);\n  }\n\n  getLogRowContextUi(row: LogRowModel, runContextQuery: () => void): React.ReactNode {\n    return LokiContextUi({\n      row,\n      languageProvider: this.languageProvider,\n      onClose: () => {\n        this.prepareContextExpr = this.prepareContextExprWithoutParsedLabels;\n      },\n      updateFilter: (contextFilters: ContextFilter[]) => {\n        this.prepareContextExpr = async (row: LogRowModel, origQuery?: DataQuery) => {\n          await this.languageProvider.start();\n          const labels = this.languageProvider.getLabelKeys();\n\n          let expr = contextFilters\n            .map((filter) => {\n              const label = filter.value;\n              if (filter && !filter.fromParser && filter.enabled && labels.includes(label)) {\n                // escape backslashes in label as users can't escape them by themselves\n                return `${label}=\"${escapeLabelValueInExactSelector(row.labels[label])}\"`;\n              }\n              return '';\n            })\n            // Filter empty strings\n            .filter((label) => !!label)\n            .join(',');\n\n          expr = `{${expr}}`;\n\n          const parserContextFilters = contextFilters.filter((filter) => filter.fromParser && filter.enabled);\n          if (parserContextFilters.length) {\n            // we should also filter for labels from parsers, let's find the right parser\n            if (origQuery) {\n              const parser = getParserFromQuery((origQuery as LokiQuery).expr);\n              if (parser) {\n                expr = addParserToQuery(expr, parser);\n              }\n            }\n            for (const filter of parserContextFilters) {\n              if (filter.enabled) {\n                expr = addLabelToQuery(expr, filter.label, '=', row.labels[filter.label]);\n              }\n            }\n          }\n          return expr;\n        };\n        if (runContextQuery) {\n          runContextQuery();\n        }\n      },\n    });\n  }\n\n  testDatasource(): Promise<{ status: string; message: string }> {\n    // Consider only last 10 minutes otherwise request takes too long\n    const nowMs = Date.now();\n    const params = {\n      start: (nowMs - 10 * 60 * 1000) * NS_IN_MS,\n      end: nowMs * NS_IN_MS,\n    };\n\n    return this.metadataRequest('labels', params).then(\n      (values) => {\n        return values.length > 0\n          ? { status: 'success', message: 'Data source connected and labels found.' }\n          : {\n              status: 'error',\n              message:\n                'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n            };\n      },\n      (err) => {\n        // we did a resource-call that failed.\n        // the only info we have, if exists, is err.data.message\n        // (when in development-mode, err.data.error exists too, but not in production-mode)\n        // things like err.status & err.statusText does not help,\n        // because those will only describe how the request between browser<>server failed\n        const info: string = err?.data?.message ?? '';\n        const infoInParentheses = info !== '' ? ` (${info})` : '';\n        const message = `Unable to fetch labels from Loki${infoInParentheses}, please check the server logs for more details`;\n        return { status: 'error', message: message };\n      }\n    );\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const { expr, maxLines, instant, tagKeys = '', titleFormat = '', textFormat = '' } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const id = `${REF_ID_STARTER_ANNOTATION}${options.annotation.name}`;\n\n    const query: LokiQuery = {\n      refId: id,\n      expr,\n      maxLines,\n      instant,\n      queryType: instant ? LokiQueryType.Instant : LokiQueryType.Range,\n    };\n\n    const request = makeRequest(query, options.range, CoreApp.Dashboard, id);\n\n    const { data } = await lastValueFrom(this.query(request));\n\n    const annotations: AnnotationEvent[] = [];\n    const splitKeys: string[] = tagKeys.split(',').filter((v: string) => v !== '');\n\n    for (const frame of data) {\n      const view = new DataFrameView<{ Time: string; Line: string; labels: Labels }>(frame);\n\n      view.forEach((row) => {\n        const { labels } = row;\n\n        const maybeDuplicatedTags = Object.entries(labels)\n          .map(([key, val]) => [key, val.trim()]) // trim all label-values\n          .filter(([key, val]) => {\n            if (val === '') {\n              // remove empty\n              return false;\n            }\n\n            // if tags are specified, remove label if does not match tags\n            if (splitKeys.length && !splitKeys.includes(key)) {\n              return false;\n            }\n\n            return true;\n          })\n          .map(([key, val]) => val); // keep only the label-value\n\n        // remove duplicates\n        const tags = Array.from(new Set(maybeDuplicatedTags));\n\n        annotations.push({\n          time: new Date(row.Time).valueOf(),\n          title: renderLegendFormat(titleFormat, labels),\n          text: renderLegendFormat(textFormat, labels) || row.Line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error: DataQueryError = cloneDeep(err);\n    error.refId = target.refId;\n\n    if (error.data && err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n\n    return error;\n  }\n\n  addAdHocFilters(queryExpr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = replaceVariables(queryExpr);\n\n    expr = adhocFilters.reduce((acc: string, filter: { key: string; operator: string; value: string }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (isRegexSelector(operator)) {\n        // Adhoc filters don't support multiselect, therefore if user selects regex operator\n        // we are going to consider value to be regex filter and use lokiRegularEscape\n        // that does not escape regex special characters (e.g. .*test.* => .*test.*)\n        value = lokiRegularEscape(value);\n      } else {\n        // Otherwise, we want to escape special characters in value\n        value = escapeLabelValueInSelector(value, operator);\n      }\n      return addLabelToQuery(acc, key, operator, value);\n    }, expr);\n\n    return returnVariables(expr);\n  }\n\n  // Used when running queries through backend\n  filterQuery(query: LokiQuery): boolean {\n    if (query.hide || query.expr === '') {\n      return false;\n    }\n    return true;\n  }\n\n  // Used when running queries through backend\n  applyTemplateVariables(target: LokiQuery, scopedVars: ScopedVars): LokiQuery {\n    // We want to interpolate these variables on backend\n    const { __interval, __interval_ms, ...rest } = scopedVars;\n\n    const exprWithAdHoc = this.addAdHocFilters(target.expr);\n\n    return {\n      ...target,\n      legendFormat: this.templateSrv.replace(target.legendFormat, rest),\n      expr: this.templateSrv.replace(exprWithAdHoc, rest, this.interpolateQueryExpr),\n    };\n  }\n\n  interpolateString(string: string, scopedVars?: ScopedVars) {\n    return this.templateSrv.replace(string, scopedVars, this.interpolateQueryExpr);\n  }\n\n  getVariables(): string[] {\n    return this.templateSrv.getVariables().map((v) => `$${v.name}`);\n  }\n\n  getQueryHints(query: LokiQuery, result: DataFrame[]): QueryHint[] {\n    return getQueryHints(query.expr, result);\n  }\n}\n\n// NOTE: these two functions are very similar to the escapeLabelValueIn* functions\n// in language_utils.ts, but they are not exactly the same algorithm, and we found\n// no way to reuse one in the another or vice versa.\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\nfunction extractLevel(dataFrame: DataFrame): LogLevel {\n  let valueField;\n  try {\n    valueField = new FieldCache(dataFrame).getFirstFieldOfType(FieldType.number);\n  } catch {}\n  return valueField?.labels ? getLogLevelFromLabels(valueField.labels) : LogLevel.unknown;\n}\n\nfunction getLogLevelFromLabels(labels: Labels): LogLevel {\n  const labelNames = ['level', 'lvl', 'loglevel'];\n  let levelLabel;\n  for (let labelName of labelNames) {\n    if (labelName in labels) {\n      levelLabel = labelName;\n      break;\n    }\n  }\n  return levelLabel ? getLogLevelFromKey(labels[levelLabel]) : LogLevel.unknown;\n}\n","import { SyntaxNode } from '@lezer/common';\nimport { sortBy } from 'lodash';\n\nimport {\n  JsonExpressionParser,\n  LabelFilter,\n  LabelParser,\n  LineComment,\n  LineFilters,\n  LogExpr,\n  LogRangeExpr,\n  Matcher,\n  parser,\n  PipelineExpr,\n  Selector,\n  UnwrapExpr,\n} from '@grafana/lezer-logql';\n\nimport { QueryBuilderLabelFilter } from '../prometheus/querybuilder/shared/types';\n\nimport { unescapeLabelValue } from './languageUtils';\nimport { LokiQueryModeller } from './querybuilder/LokiQueryModeller';\nimport { buildVisualQueryFromString } from './querybuilder/parsing';\n\ntype Position = { from: number; to: number };\n/**\n * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.\n *\n * It uses LogQL parser to find instances of labels, alters them and then splices them back into the query.\n * In a case when we have parser, instead of adding new instance of label it adds label filter after the parser.\n *\n * This operates on substrings of the query with labels and operates just on those. This makes this\n * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.\n *\n * @param query\n * @param key\n * @param value\n * @param operator\n */\nexport function addLabelToQuery(query: string, key: string, operator: string, value: string): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  const streamSelectorPositions = getStreamSelectorPositions(query);\n  const hasStreamSelectorMatchers = getMatcherInStreamPositions(query);\n  const everyStreamSelectorHasMatcher = streamSelectorPositions.every((streamSelectorPosition) =>\n    hasStreamSelectorMatchers.some(\n      (matcherPosition) =>\n        matcherPosition.from >= streamSelectorPosition.from && matcherPosition.to <= streamSelectorPosition.to\n    )\n  );\n  const parserPositions = getParserPositions(query);\n  const labelFilterPositions = getLabelFilterPositions(query);\n  if (!streamSelectorPositions.length) {\n    return query;\n  }\n\n  const filter = toLabelFilter(key, value, operator);\n  // If we have non-empty stream selector and parser/label filter, we want to add a new label filter after the last one.\n  // If some of the stream selectors don't have matchers, we want to add new matcher to the all stream selectors.\n  if (everyStreamSelectorHasMatcher && (labelFilterPositions.length || parserPositions.length)) {\n    const positionToAdd = findLastPosition([...labelFilterPositions, ...parserPositions]);\n    return addFilterAsLabelFilter(query, [positionToAdd], filter);\n  } else {\n    return addFilterToStreamSelector(query, streamSelectorPositions, filter);\n  }\n}\n\n/**\n * Adds parser to existing query. Useful for query modification for hints.\n * It uses LogQL parser to find instances of stream selectors or line filters and adds parser after them.\n *\n * @param query\n * @param parser\n */\nexport function addParserToQuery(query: string, parser: string): string {\n  const lineFilterPositions = getLineFiltersPositions(query);\n\n  if (lineFilterPositions.length) {\n    return addParser(query, lineFilterPositions, parser);\n  } else {\n    const streamSelectorPositions = getStreamSelectorPositions(query);\n    return addParser(query, streamSelectorPositions, parser);\n  }\n}\n\n/**\n * Adds filtering for pipeline errors to existing query. Useful for query modification for hints.\n * It uses LogQL parser to find parsers and adds pipeline errors filtering after them.\n *\n * @param query\n */\nexport function addNoPipelineErrorToQuery(query: string): string {\n  const parserPositions = getParserPositions(query);\n  if (!parserPositions.length) {\n    return query;\n  }\n\n  const filter = toLabelFilter('__error__', '', '=');\n  return addFilterAsLabelFilter(query, parserPositions, filter);\n}\n\n/**\n * Adds label format to existing query. Useful for query modification for hints.\n * It uses LogQL parser to find log query and add label format at the end.\n *\n * @param query\n * @param labelFormat\n */\nexport function addLabelFormatToQuery(query: string, labelFormat: { originalLabel: string; renameTo: string }): string {\n  const logQueryPositions = getLogQueryPositions(query);\n  return addLabelFormat(query, logQueryPositions, labelFormat);\n}\n\n/**\n * Removes all comments from query.\n * It uses  LogQL parser to find all LineComments and removes them.\n */\nexport function removeCommentsFromQuery(query: string): string {\n  const lineCommentPositions = getLineCommentPositions(query);\n\n  if (!lineCommentPositions.length) {\n    return query;\n  }\n\n  let newQuery = '';\n  let prev = 0;\n\n  for (let lineCommentPosition of lineCommentPositions) {\n    newQuery = newQuery + query.substring(prev, lineCommentPosition.from);\n    prev = lineCommentPosition.to;\n  }\n  return newQuery;\n}\n\n/**\n * Parse the string and get all Selector positions in the query together with parsed representation of the\n * selector.\n * @param query\n */\nexport function getStreamSelectorPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ type, from, to }): false | void => {\n      if (type.id === Selector) {\n        positions.push({ from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\nfunction getMatcherInStreamPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ node }): false | void => {\n      if (node.type.id === Selector) {\n        positions.push(...getAllPositionsInNodeByType(query, node, Matcher));\n      }\n    },\n  });\n  return positions;\n}\n\n/**\n * Parse the string and get all LabelParser positions in the query.\n * @param query\n */\nexport function getParserPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ type, from, to }): false | void => {\n      if (type.id === LabelParser || type.id === JsonExpressionParser) {\n        positions.push({ from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\n/**\n * Parse the string and get all LabelFilter positions in the query.\n * @param query\n */\nexport function getLabelFilterPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ type, from, to }): false | void => {\n      if (type.id === LabelFilter) {\n        positions.push({ from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\n/**\n * Parse the string and get all Line filter positions in the query.\n * @param query\n */\nfunction getLineFiltersPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ type, node }): false | void => {\n      if (type.id === LineFilters) {\n        positions.push({ from: node.from, to: node.to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\n/**\n * Parse the string and get all Log query positions in the query.\n * @param query\n */\nfunction getLogQueryPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ type, from, to, node }): false | void => {\n      if (type.id === LogExpr) {\n        positions.push({ from, to });\n        return false;\n      }\n\n      // This is a case in metrics query\n      if (type.id === LogRangeExpr) {\n        // Unfortunately, LogRangeExpr includes both log and non-log (e.g. Duration/Range/...) parts of query.\n        // We get position of all log-parts within LogRangeExpr: Selector, PipelineExpr and UnwrapExpr.\n        const logPartsPositions: Position[] = [];\n        const selector = node.getChild(Selector);\n        if (selector) {\n          logPartsPositions.push({ from: selector.from, to: selector.to });\n        }\n\n        const pipeline = node.getChild(PipelineExpr);\n        if (pipeline) {\n          logPartsPositions.push({ from: pipeline.from, to: pipeline.to });\n        }\n\n        const unwrap = node.getChild(UnwrapExpr);\n        if (unwrap) {\n          logPartsPositions.push({ from: unwrap.from, to: unwrap.to });\n        }\n\n        // We sort them and then pick \"from\" from first position and \"to\" from last position.\n        const sorted = sortBy(logPartsPositions, (position) => position.to);\n        positions.push({ from: sorted[0].from, to: sorted[sorted.length - 1].to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\nexport function toLabelFilter(key: string, value: string, operator: string): QueryBuilderLabelFilter {\n  // We need to make sure that we convert the value back to string because it may be a number\n  return { label: key, op: operator, value };\n}\n\n/**\n * Add filter as to stream selectors\n * @param query\n * @param vectorSelectorPositions\n * @param filter\n */\nfunction addFilterToStreamSelector(\n  query: string,\n  vectorSelectorPositions: Position[],\n  filter: QueryBuilderLabelFilter\n): string {\n  const modeller = new LokiQueryModeller();\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < vectorSelectorPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n\n    const match = vectorSelectorPositions[i];\n    const isLast = i === vectorSelectorPositions.length - 1;\n\n    const start = query.substring(prev, match.from);\n    const end = isLast ? query.substring(match.to) : '';\n    const matchVisQuery = buildVisualQueryFromString(query.substring(match.from, match.to));\n\n    if (!labelExists(matchVisQuery.query.labels, filter)) {\n      // We don't want to add duplicate labels.\n      matchVisQuery.query.labels.push(filter);\n    }\n    const newLabels = modeller.renderQuery(matchVisQuery.query);\n    newQuery += start + newLabels + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\n/**\n * Add filter as label filter after the parsers\n * @param query\n * @param positionsToAddAfter\n * @param filter\n */\nexport function addFilterAsLabelFilter(\n  query: string,\n  positionsToAddAfter: Position[],\n  filter: QueryBuilderLabelFilter\n): string {\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < positionsToAddAfter.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n    const match = positionsToAddAfter[i];\n    const isLast = i === positionsToAddAfter.length - 1;\n\n    const start = query.substring(prev, match.to);\n    const end = isLast ? query.substring(match.to) : '';\n\n    // we now unescape all escaped values again, because we are using backticks which can handle those cases.\n    // we also don't care about the operator here, because we need to unescape for both, regex and equal.\n    const labelFilter = ` | ${filter.label}${filter.op}\\`${unescapeLabelValue(filter.value)}\\``;\n    newQuery += start + labelFilter + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\n/**\n * Add parser after line filter or stream selector\n * @param query\n * @param queryPartPositions\n * @param parser\n */\nfunction addParser(query: string, queryPartPositions: Position[], parser: string): string {\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < queryPartPositions.length; i++) {\n    // Splice on a string for each matched vector selector\n    const match = queryPartPositions[i];\n    const isLast = i === queryPartPositions.length - 1;\n\n    const start = query.substring(prev, match.to);\n    const end = isLast ? query.substring(match.to) : '';\n\n    // Add parser\n    newQuery += start + ` | ${parser}` + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\n/**\n * Add filter as label filter after the parsers\n * @param query\n * @param logQueryPositions\n * @param labelFormat\n */\nfunction addLabelFormat(\n  query: string,\n  logQueryPositions: Position[],\n  labelFormat: { originalLabel: string; renameTo: string }\n): string {\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < logQueryPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n    const match = logQueryPositions[i];\n    const isLast = i === logQueryPositions.length - 1;\n\n    const start = query.substring(prev, match.to);\n    const end = isLast ? query.substring(match.to) : '';\n\n    const labelFilter = ` | label_format ${labelFormat.renameTo}=${labelFormat.originalLabel}`;\n    newQuery += start + labelFilter + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\nexport function addLineFilter(query: string): string {\n  const streamSelectorPositions = getStreamSelectorPositions(query);\n  const streamSelectorEnd = streamSelectorPositions[0].to;\n\n  const newQueryExpr = query.slice(0, streamSelectorEnd) + ' |= ``' + query.slice(streamSelectorEnd);\n  return newQueryExpr;\n}\n\nfunction getLineCommentPositions(query: string): Position[] {\n  const tree = parser.parse(query);\n  const positions: Position[] = [];\n  tree.iterate({\n    enter: ({ type, from, to }): false | void => {\n      if (type.id === LineComment) {\n        positions.push({ from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\n/**\n * Check if label exists in the list of labels but ignore the operator.\n * @param labels\n * @param filter\n */\nfunction labelExists(labels: QueryBuilderLabelFilter[], filter: QueryBuilderLabelFilter) {\n  return labels.find((label) => label.label === filter.label && label.value === filter.value);\n}\n\n/**\n * Return the last position based on \"to\" property\n * @param positions\n */\nexport function findLastPosition(positions: Position[]): Position {\n  return positions.reduce((prev, current) => (prev.to > current.to ? prev : current));\n}\n\nfunction getAllPositionsInNodeByType(query: string, node: SyntaxNode, type: number): Position[] {\n  if (node.type.id === type) {\n    return [{ from: node.from, to: node.to }];\n  }\n\n  const positions: Position[] = [];\n  let pos = 0;\n  let child = node.childAfter(pos);\n  while (child) {\n    positions.push(...getAllPositionsInNodeByType(query, child, type));\n    pos = child.to;\n    child = node.childAfter(pos);\n  }\n  return positions;\n}\n","import { SyntaxNode } from '@lezer/common';\nimport { escapeRegExp } from 'lodash';\n\nimport {\n  parser,\n  LineFilter,\n  PipeExact,\n  PipeMatch,\n  Filter,\n  String,\n  LabelFormatExpr,\n  Selector,\n  PipelineExpr,\n  LabelParser,\n  JsonExpressionParser,\n  LabelFilter,\n  MetricExpr,\n  Matcher,\n  Identifier,\n} from '@grafana/lezer-logql';\n\nimport { ErrorId } from '../prometheus/querybuilder/shared/parsingUtils';\n\nimport { getStreamSelectorPositions } from './modifyQuery';\nimport { LokiQuery, LokiQueryType } from './types';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  const results = [];\n\n  const tree = parser.parse(input);\n  const filters: SyntaxNode[] = [];\n  tree.iterate({\n    enter: ({ type, node }): void => {\n      if (type.id === LineFilter) {\n        filters.push(node);\n      }\n    },\n  });\n\n  for (let filter of filters) {\n    const pipeExact = filter.getChild(Filter)?.getChild(PipeExact);\n    const pipeMatch = filter.getChild(Filter)?.getChild(PipeMatch);\n    const string = filter.getChild(String);\n\n    if ((!pipeExact && !pipeMatch) || !string) {\n      continue;\n    }\n\n    const filterTerm = input.substring(string.from, string.to).trim();\n    const backtickedTerm = filterTerm[0] === '`';\n    const unwrappedFilterTerm = filterTerm.substring(1, filterTerm.length - 1);\n\n    if (!unwrappedFilterTerm) {\n      continue;\n    }\n\n    let resultTerm = '';\n\n    // Only filter expressions with |~ operator are treated as regular expressions\n    if (pipeMatch) {\n      // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n      // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n      resultTerm = backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\');\n    } else {\n      // We need to escape this string so it is not matched as regular expression\n      resultTerm = escapeRegExp(unwrappedFilterTerm);\n    }\n\n    if (resultTerm) {\n      results.push(resultTerm);\n    }\n  }\n  return results;\n}\n\n// we are migrating from `.instant` and `.range` to `.queryType`\n// this function returns a new query object that:\n// - has `.queryType`\n// - does not have `.instant`\n// - does not have `.range`\nexport function getNormalizedLokiQuery(query: LokiQuery): LokiQuery {\n  //  if queryType field contains invalid data we behave as if the queryType is empty\n  const { queryType } = query;\n  const hasValidQueryType =\n    queryType === LokiQueryType.Range || queryType === LokiQueryType.Instant || queryType === LokiQueryType.Stream;\n\n  // if queryType exists, it is respected\n  if (hasValidQueryType) {\n    const { instant, range, ...rest } = query;\n    return rest;\n  }\n\n  // if no queryType, and instant===true, it's instant\n  if (query.instant === true) {\n    const { instant, range, ...rest } = query;\n    return { ...rest, queryType: LokiQueryType.Instant };\n  }\n\n  // otherwise it is range\n  const { instant, range, ...rest } = query;\n  return { ...rest, queryType: LokiQueryType.Range };\n}\n\nconst tagsToObscure = ['String', 'Identifier', 'LineComment', 'Number'];\nconst partsToKeep = ['__error__', '__interval', '__interval_ms'];\nexport function obfuscate(query: string): string {\n  let obfuscatedQuery: string = query;\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ name, from, to }): false | void => {\n      const queryPart = query.substring(from, to);\n      if (tagsToObscure.includes(name) && !partsToKeep.includes(queryPart)) {\n        obfuscatedQuery = obfuscatedQuery.replace(queryPart, name);\n      }\n    },\n  });\n  return obfuscatedQuery;\n}\n\nexport function parseToNodeNamesArray(query: string): string[] {\n  const queryParts: string[] = [];\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ name }): false | void => {\n      queryParts.push(name);\n    },\n  });\n  return queryParts;\n}\n\nexport function isValidQuery(query: string): boolean {\n  let isValid = true;\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ type }): false | void => {\n      if (type.id === ErrorId) {\n        isValid = false;\n      }\n    },\n  });\n  return isValid;\n}\n\nexport function isLogsQuery(query: string): boolean {\n  let isLogsQuery = true;\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ type }): false | void => {\n      if (type.id === MetricExpr) {\n        isLogsQuery = false;\n      }\n    },\n  });\n  return isLogsQuery;\n}\n\nexport function isQueryWithParser(query: string): { queryWithParser: boolean; parserCount: number } {\n  let parserCount = 0;\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ type }): false | void => {\n      if (type.id === LabelParser || type.id === JsonExpressionParser) {\n        parserCount++;\n      }\n    },\n  });\n  return { queryWithParser: parserCount > 0, parserCount };\n}\n\nexport function getParserFromQuery(query: string) {\n  const tree = parser.parse(query);\n  let logParser;\n  tree.iterate({\n    enter: (node: SyntaxNode): false | void => {\n      if (node.type.id === LabelParser || node.type.id === JsonExpressionParser) {\n        logParser = query.substring(node.from, node.to).trim();\n        return false;\n      }\n    },\n  });\n\n  return logParser;\n}\n\nexport function isQueryPipelineErrorFiltering(query: string): boolean {\n  let isQueryPipelineErrorFiltering = false;\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ type, node }): false | void => {\n      if (type.id === LabelFilter) {\n        const label = node.getChild(Matcher)?.getChild(Identifier);\n        if (label) {\n          const labelName = query.substring(label.from, label.to);\n          if (labelName === '__error__') {\n            isQueryPipelineErrorFiltering = true;\n          }\n        }\n      }\n    },\n  });\n\n  return isQueryPipelineErrorFiltering;\n}\n\nexport function isQueryWithLabelFormat(query: string): boolean {\n  let queryWithLabelFormat = false;\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: ({ type }): false | void => {\n      if (type.id === LabelFormatExpr) {\n        queryWithLabelFormat = true;\n      }\n    },\n  });\n  return queryWithLabelFormat;\n}\n\nexport function getLogQueryFromMetricsQuery(query: string): string {\n  if (isLogsQuery(query)) {\n    return query;\n  }\n\n  const tree = parser.parse(query);\n\n  // Log query in metrics query composes of Selector & PipelineExpr\n  let selector = '';\n  tree.iterate({\n    enter: ({ type, from, to }): false | void => {\n      if (type.id === Selector) {\n        selector = query.substring(from, to);\n        return false;\n      }\n    },\n  });\n\n  let pipelineExpr = '';\n  tree.iterate({\n    enter: ({ type, from, to }): false | void => {\n      if (type.id === PipelineExpr) {\n        pipelineExpr = query.substring(from, to);\n        return false;\n      }\n    },\n  });\n\n  return selector + pipelineExpr;\n}\n\nexport function isQueryWithLabelFilter(query: string): boolean {\n  const tree = parser.parse(query);\n  let hasLabelFilter = false;\n\n  tree.iterate({\n    enter: ({ type, node }): false | void => {\n      if (type.id === LabelFilter) {\n        hasLabelFilter = true;\n        return;\n      }\n    },\n  });\n\n  return hasLabelFilter;\n}\n\nexport function isQueryWithLineFilter(query: string): boolean {\n  const tree = parser.parse(query);\n  let queryWithLineFilter = false;\n\n  tree.iterate({\n    enter: ({ type }): false | void => {\n      if (type.id === LineFilter) {\n        queryWithLineFilter = true;\n        return;\n      }\n    },\n  });\n\n  return queryWithLineFilter;\n}\n\nexport function getStreamSelectorsFromQuery(query: string): string[] {\n  const labelMatcherPositions = getStreamSelectorPositions(query);\n\n  const labelMatchers = labelMatcherPositions.map((labelMatcher) => {\n    return query.slice(labelMatcher.from, labelMatcher.to);\n  });\n\n  return labelMatchers;\n}\n","import { LokiAndPromQueryModellerBase } from '../../prometheus/querybuilder/shared/LokiAndPromQueryModellerBase';\nimport { QueryBuilderLabelFilter } from '../../prometheus/querybuilder/shared/types';\n\nimport { getOperationDefinitions } from './operations';\nimport { LokiOperationId, LokiQueryPattern, LokiQueryPatternType, LokiVisualQueryOperationCategory } from './types';\n\nexport class LokiQueryModeller extends LokiAndPromQueryModellerBase {\n  constructor() {\n    super(getOperationDefinitions);\n\n    this.setOperationCategories([\n      LokiVisualQueryOperationCategory.Aggregations,\n      LokiVisualQueryOperationCategory.RangeFunctions,\n      LokiVisualQueryOperationCategory.Formats,\n      LokiVisualQueryOperationCategory.BinaryOps,\n      LokiVisualQueryOperationCategory.LabelFilters,\n      LokiVisualQueryOperationCategory.LineFilters,\n    ]);\n  }\n\n  renderLabels(labels: QueryBuilderLabelFilter[]) {\n    if (labels.length === 0) {\n      return '{}';\n    }\n\n    return super.renderLabels(labels);\n  }\n\n  getQueryPatterns(): LokiQueryPattern[] {\n    return [\n      {\n        name: 'Parse log lines with logfmt parser',\n        type: LokiQueryPatternType.Log,\n        // {} | logfmt | __error__=``\n        operations: [\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n        ],\n      },\n      {\n        name: 'Parse log lines with JSON parser',\n        type: LokiQueryPatternType.Log,\n        // {} | json | __error__=``\n        operations: [\n          { id: LokiOperationId.Json, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n        ],\n      },\n      {\n        name: 'Filter log line and parse with logfmt parser',\n        type: LokiQueryPatternType.Log,\n        // {} |= `` | logfmt | __error__=``\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n        ],\n      },\n      {\n        name: 'Filter log lines and parse with json parser',\n        type: LokiQueryPatternType.Log,\n        // {} |= `` | json | __error__=``\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Json, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n        ],\n      },\n      {\n        name: 'Parse log line with logfmt parser and use label filter',\n        type: LokiQueryPatternType.Log,\n        // {} |= `` | logfmt | __error__=`` | label=`value`\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.LabelFilter, params: ['label', '=', 'value'] },\n        ],\n      },\n      {\n        name: 'Parse log lines with nested json',\n        type: LokiQueryPatternType.Log,\n        // {} |= `` | json | line_format `{{ .message}}` | json\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Json, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.LineFormat, params: ['{{.message}}'] },\n          { id: LokiOperationId.Json, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n        ],\n      },\n      {\n        name: 'Reformat log lines',\n        type: LokiQueryPatternType.Log,\n        // {} |= `` | logfmt | line_format `{{.message}}`\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.LineFormat, params: ['{{.message}}'] },\n        ],\n      },\n      {\n        name: 'Rename lvl label to level',\n        type: LokiQueryPatternType.Log,\n        // {} |= `` | logfmt | label_format level=lvl\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.LabelFormat, params: ['lvl', 'level'] },\n        ],\n      },\n      {\n        name: 'Query on value inside a log line',\n        type: LokiQueryPatternType.Metric,\n        // sum(sum_over_time({ | logfmt | __error__=`` | unwrap | __error__=`` [$__interval]))\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.Unwrap, params: [''] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.SumOverTime, params: ['$__interval'] },\n          { id: LokiOperationId.Sum, params: [] },\n        ],\n      },\n      {\n        name: 'Total requests per label of streams',\n        type: LokiQueryPatternType.Metric,\n        // sum by() (count_over_time({}[$__interval)\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.CountOverTime, params: ['$__interval'] },\n          { id: LokiOperationId.Sum, params: [] },\n        ],\n      },\n      {\n        name: 'Total requests per parsed label or label of streams',\n        type: LokiQueryPatternType.Metric,\n        // sum by() (count_over_time({}| logfmt | __error__=`` [$__interval))\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.CountOverTime, params: ['$__interval'] },\n          { id: LokiOperationId.Sum, params: [] },\n        ],\n      },\n      {\n        name: 'Bytes used by a log stream',\n        type: LokiQueryPatternType.Metric,\n        // bytes_over_time({}[$__interval])\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.BytesOverTime, params: ['$__interval'] },\n        ],\n      },\n      {\n        name: 'Count of log lines per stream',\n        type: LokiQueryPatternType.Metric,\n        // count_over_time({}[$__interval])\n        operations: [\n          { id: LokiOperationId.LineContains, params: [''] },\n          { id: LokiOperationId.CountOverTime, params: ['$__interval'] },\n        ],\n      },\n      {\n        name: 'Top N results by label or parsed label',\n        type: LokiQueryPatternType.Metric,\n        // topk(10, sum by () (count_over_time({} | logfmt | __error__=`` [$__interval])))\n        operations: [\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.CountOverTime, params: ['$__interval'] },\n          { id: LokiOperationId.Sum, params: [] },\n          { id: LokiOperationId.TopK, params: [10] },\n        ],\n      },\n      {\n        name: 'Extracted quantile',\n        type: LokiQueryPatternType.Metric,\n        // quantile_over_time(0.5,{} | logfmt | unwrap latency[$__interval]) by ()\n        operations: [\n          { id: LokiOperationId.Logfmt, params: [] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.Unwrap, params: ['latency'] },\n          { id: LokiOperationId.LabelFilterNoErrors, params: [] },\n          { id: LokiOperationId.QuantileOverTime, params: ['$__interval', 0.5] },\n          { id: LokiOperationId.Sum, params: [] },\n        ],\n      },\n    ];\n  }\n}\n\nexport const lokiQueryModeller = new LokiQueryModeller();\n","import { defaultAddOperationHandler } from '../../prometheus/querybuilder/shared/operationUtils';\nimport {\n  QueryBuilderOperation,\n  QueryBuilderOperationDef,\n  QueryBuilderOperationParamDef,\n} from '../../prometheus/querybuilder/shared/types';\n\nimport { LokiOperationId, LokiVisualQueryOperationCategory } from './types';\n\nexport const binaryScalarDefs = [\n  {\n    id: LokiOperationId.Addition,\n    name: 'Add scalar',\n    sign: '+',\n  },\n  {\n    id: LokiOperationId.Subtraction,\n    name: 'Subtract scalar',\n    sign: '-',\n  },\n  {\n    id: LokiOperationId.MultiplyBy,\n    name: 'Multiply by scalar',\n    sign: '*',\n  },\n  {\n    id: LokiOperationId.DivideBy,\n    name: 'Divide by scalar',\n    sign: '/',\n  },\n  {\n    id: LokiOperationId.Modulo,\n    name: 'Modulo by scalar',\n    sign: '%',\n  },\n  {\n    id: LokiOperationId.Exponent,\n    name: 'Exponent',\n    sign: '^',\n  },\n  {\n    id: LokiOperationId.EqualTo,\n    name: 'Equal to',\n    sign: '==',\n    comparison: true,\n  },\n  {\n    id: LokiOperationId.NotEqualTo,\n    name: 'Not equal to',\n    sign: '!=',\n    comparison: true,\n  },\n  {\n    id: LokiOperationId.GreaterThan,\n    name: 'Greater than',\n    sign: '>',\n    comparison: true,\n  },\n  {\n    id: LokiOperationId.LessThan,\n    name: 'Less than',\n    sign: '<',\n    comparison: true,\n  },\n  {\n    id: LokiOperationId.GreaterOrEqual,\n    name: 'Greater or equal to',\n    sign: '>=',\n    comparison: true,\n  },\n  {\n    id: LokiOperationId.LessOrEqual,\n    name: 'Less or equal to',\n    sign: '<=',\n    comparison: true,\n  },\n];\n\n// Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies\n// both the operator and the operand in a single input\nexport const binaryScalarOperations: QueryBuilderOperationDef[] = binaryScalarDefs.map((opDef) => {\n  const params: QueryBuilderOperationParamDef[] = [{ name: 'Value', type: 'number' }];\n  const defaultParams: any[] = [2];\n  if (opDef.comparison) {\n    params.unshift({\n      name: 'Bool',\n      type: 'boolean',\n      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.',\n    });\n    defaultParams.unshift(false);\n  }\n\n  return {\n    id: opDef.id,\n    name: opDef.name,\n    params,\n    defaultParams,\n    alternativesKey: 'binary scalar operations',\n    category: LokiVisualQueryOperationCategory.BinaryOps,\n    renderer: getSimpleBinaryRenderer(opDef.sign),\n    addOperationHandler: defaultAddOperationHandler,\n  };\n});\n\nfunction getSimpleBinaryRenderer(operator: string) {\n  return function binaryRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    let param = model.params[0];\n    let bool = '';\n    if (model.params.length === 2) {\n      param = model.params[1];\n      bool = model.params[0] ? ' bool' : '';\n    }\n\n    return `${innerExpr} ${operator}${bool} ${param}`;\n  };\n}\n","import React, { useState } from 'react';\n\nimport { SelectableValue, toOption } from '@grafana/data';\nimport { Select } from '@grafana/ui';\n\nimport { getOperationParamId } from '../../../prometheus/querybuilder/shared/operationUtils';\nimport { QueryBuilderOperationParamEditorProps } from '../../../prometheus/querybuilder/shared/types';\nimport { LokiDatasource } from '../../datasource';\nimport { getLogQueryFromMetricsQuery, isValidQuery } from '../../queryUtils';\nimport { extractUnwrapLabelKeysFromDataFrame } from '../../responseUtils';\nimport { lokiQueryModeller } from '../LokiQueryModeller';\nimport { LokiVisualQuery } from '../types';\n\nexport function UnwrapParamEditor({\n  onChange,\n  index,\n  operationIndex,\n  value,\n  query,\n  datasource,\n}: QueryBuilderOperationParamEditorProps) {\n  const [state, setState] = useState<{\n    options?: Array<SelectableValue<string>>;\n    isLoading?: boolean;\n  }>({});\n\n  return (\n    <Select\n      inputId={getOperationParamId(operationIndex, index)}\n      onOpenMenu={async () => {\n        // This check is always true, we do it to make typescript happy\n        if (datasource instanceof LokiDatasource) {\n          setState({ isLoading: true });\n          const options = await loadUnwrapOptions(query, datasource);\n          setState({ options, isLoading: undefined });\n        }\n      }}\n      isLoading={state.isLoading}\n      allowCustomValue\n      noOptionsMessage=\"No labels found\"\n      loadingMessage=\"Loading labels\"\n      options={state.options}\n      value={value ? toOption(value.toString()) : null}\n      onChange={(value) => {\n        if (value.value) {\n          onChange(index, value.value);\n        }\n      }}\n    />\n  );\n}\n\nasync function loadUnwrapOptions(\n  query: LokiVisualQuery,\n  datasource: LokiDatasource\n): Promise<Array<SelectableValue<string>>> {\n  const queryExpr = lokiQueryModeller.renderQuery(query);\n  const logExpr = getLogQueryFromMetricsQuery(queryExpr);\n  if (!isValidQuery(logExpr)) {\n    return [];\n  }\n\n  const samples = await datasource.getDataSamples({ expr: logExpr, refId: 'unwrap_samples' });\n  const unwrapLabels = extractUnwrapLabelKeysFromDataFrame(samples[0]);\n\n  const labelOptions = unwrapLabels.map((label) => ({\n    label,\n    value: label,\n  }));\n\n  return labelOptions;\n}\n","import { LabelParamEditor } from '../../prometheus/querybuilder/components/LabelParamEditor';\nimport {\n  getAggregationExplainer,\n  getLastLabelRemovedHandler,\n  getOnLabelAddedHandler,\n  getPromAndLokiOperationDisplayName,\n} from '../../prometheus/querybuilder/shared/operationUtils';\nimport {\n  QueryBuilderOperation,\n  QueryBuilderOperationDef,\n  QueryBuilderOperationParamDef,\n  VisualQueryModeller,\n} from '../../prometheus/querybuilder/shared/types';\nimport { FUNCTIONS } from '../syntax';\n\nimport { LokiOperationId, LokiOperationOrder, LokiVisualQuery, LokiVisualQueryOperationCategory } from './types';\n\nexport function createRangeOperation(name: string, isRangeOperationWithGrouping?: boolean): QueryBuilderOperationDef {\n  const params = [getRangeVectorParamDef()];\n  const defaultParams = ['$__interval'];\n  let paramChangedHandler = undefined;\n\n  if (name === LokiOperationId.QuantileOverTime) {\n    defaultParams.push('0.95');\n    params.push({\n      name: 'Quantile',\n      type: 'number',\n    });\n  }\n\n  if (isRangeOperationWithGrouping) {\n    params.push({\n      name: 'By label',\n      type: 'string',\n      restParam: true,\n      optional: true,\n    });\n\n    paramChangedHandler = getOnLabelAddedHandler(`__${name}_by`);\n  }\n\n  return {\n    id: name,\n    name: getPromAndLokiOperationDisplayName(name),\n    params: params,\n    defaultParams,\n    alternativesKey: 'range function',\n    category: LokiVisualQueryOperationCategory.RangeFunctions,\n    orderRank: LokiOperationOrder.RangeVectorFunction,\n    renderer: operationWithRangeVectorRenderer,\n    addOperationHandler: addLokiOperation,\n    paramChangedHandler,\n    explainHandler: (op, def) => {\n      let opDocs = FUNCTIONS.find((x) => x.insertText === op.id)?.documentation ?? '';\n\n      if (op.params[0] === '$__interval') {\n        return `${opDocs} \\`$__interval\\` is a variable that will be replaced with the [calculated interval](https://grafana.com/docs/grafana/latest/dashboards/variables/add-template-variables/#__interval) based on the time range and width of the graph. In Dashboards, you can affect the interval variable using **Max data points** and **Min interval**. You can find these options under **Query options** right of the data source select dropdown.`;\n      } else {\n        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \\`${op.params[0]}\\`.`;\n      }\n    },\n  };\n}\n\nexport function createRangeOperationWithGrouping(name: string): QueryBuilderOperationDef[] {\n  const rangeOperation = createRangeOperation(name, true);\n  // Copy range operation params without the last param\n  const params = rangeOperation.params.slice(0, -1);\n  const operations: QueryBuilderOperationDef[] = [\n    rangeOperation,\n    {\n      id: `__${name}_by`,\n      name: `${getPromAndLokiOperationDisplayName(name)} by`,\n      params: [\n        ...params,\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [...rangeOperation.defaultParams, ''],\n      alternativesKey: 'range function with grouping',\n      category: LokiVisualQueryOperationCategory.RangeFunctions,\n      renderer: getRangeAggregationWithGroupingRenderer(name, 'by'),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'by'),\n      addOperationHandler: addLokiOperation,\n      hideFromList: true,\n    },\n    {\n      id: `__${name}_without`,\n      name: `${getPromAndLokiOperationDisplayName(name)} without`,\n      params: [\n        ...params,\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [...rangeOperation.defaultParams, ''],\n      alternativesKey: 'range function with grouping',\n      category: LokiVisualQueryOperationCategory.RangeFunctions,\n      renderer: getRangeAggregationWithGroupingRenderer(name, 'without'),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'without'),\n      addOperationHandler: addLokiOperation,\n      hideFromList: true,\n    },\n  ];\n\n  return operations;\n}\n\nexport function getRangeAggregationWithGroupingRenderer(aggregation: string, grouping: 'by' | 'without') {\n  return function aggregationRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    const restParamIndex = def.params.findIndex((param) => param.restParam);\n    const params = model.params.slice(0, restParamIndex);\n    const restParams = model.params.slice(restParamIndex);\n\n    if (params.length === 2 && aggregation === LokiOperationId.QuantileOverTime) {\n      return `${aggregation}(${params[1]}, ${innerExpr} [${params[0]}]) ${grouping} (${restParams.join(', ')})`;\n    }\n\n    return `${aggregation}(${innerExpr} [${params[0]}]) ${grouping} (${restParams.join(', ')})`;\n  };\n}\n\nfunction operationWithRangeVectorRenderer(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string\n) {\n  const params = model.params ?? [];\n  const rangeVector = params[0] ?? '$__interval';\n  // QuantileOverTime is only range vector with more than one param\n  if (params.length === 2 && model.id === LokiOperationId.QuantileOverTime) {\n    const quantile = params[1];\n    return `${model.id}(${quantile}, ${innerExpr} [${rangeVector}])`;\n  }\n\n  return `${model.id}(${innerExpr} [${params[0] ?? '$__interval'}])`;\n}\n\nexport function labelFilterRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  const integerOperators = ['<', '<=', '>', '>='];\n\n  if (integerOperators.includes(String(model.params[1]))) {\n    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;\n  }\n\n  return `${innerExpr} | ${model.params[0]} ${model.params[1]} \\`${model.params[2]}\\``;\n}\n\nexport function pipelineRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  return `${innerExpr} | ${model.id}`;\n}\n\nfunction isRangeVectorFunction(def: QueryBuilderOperationDef) {\n  return def.category === LokiVisualQueryOperationCategory.RangeFunctions;\n}\n\nfunction getIndexOfOrLast(\n  operations: QueryBuilderOperation[],\n  queryModeller: VisualQueryModeller,\n  condition: (def: QueryBuilderOperationDef) => boolean\n) {\n  const index = operations.findIndex((x) => {\n    const opDef = queryModeller.getOperationDef(x.id);\n    if (!opDef) {\n      return false;\n    }\n    return condition(opDef);\n  });\n\n  return index === -1 ? operations.length : index;\n}\n\nexport function addLokiOperation(\n  def: QueryBuilderOperationDef,\n  query: LokiVisualQuery,\n  modeller: VisualQueryModeller\n): LokiVisualQuery {\n  const newOperation: QueryBuilderOperation = {\n    id: def.id,\n    params: def.defaultParams,\n  };\n\n  const operations = [...query.operations];\n\n  const existingRangeVectorFunction = operations.find((x) => {\n    const opDef = modeller.getOperationDef(x.id);\n    if (!opDef) {\n      return false;\n    }\n    return isRangeVectorFunction(opDef);\n  });\n\n  switch (def.category) {\n    case LokiVisualQueryOperationCategory.Aggregations:\n    case LokiVisualQueryOperationCategory.Functions:\n      // If we are adding a function but we have not range vector function yet add one\n      if (!existingRangeVectorFunction) {\n        const placeToInsert = getIndexOfOrLast(\n          operations,\n          modeller,\n          (def) => def.category === LokiVisualQueryOperationCategory.Functions\n        );\n        operations.splice(placeToInsert, 0, { id: LokiOperationId.Rate, params: ['$__interval'] });\n      }\n      operations.push(newOperation);\n      break;\n    case LokiVisualQueryOperationCategory.RangeFunctions:\n      // If adding a range function and range function is already added replace it\n      if (existingRangeVectorFunction) {\n        const index = operations.indexOf(existingRangeVectorFunction);\n        operations[index] = newOperation;\n        break;\n      }\n\n    // Add range functions after any formats, line filters and label filters\n    default:\n      const placeToInsert = getIndexOfOrLast(\n        operations,\n        modeller,\n        (x) => (def.orderRank ?? 100) < (x.orderRank ?? 100)\n      );\n      operations.splice(placeToInsert, 0, newOperation);\n      break;\n  }\n\n  return {\n    ...query,\n    operations,\n  };\n}\n\nexport function addNestedQueryHandler(def: QueryBuilderOperationDef, query: LokiVisualQuery): LokiVisualQuery {\n  return {\n    ...query,\n    binaryQueries: [\n      ...(query.binaryQueries ?? []),\n      {\n        operator: '/',\n        query,\n      },\n    ],\n  };\n}\n\nexport function getLineFilterRenderer(operation: string, caseInsensitive?: boolean) {\n  return function lineFilterRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    if (caseInsensitive) {\n      return `${innerExpr} ${operation} \\`(?i)${model.params[0]}\\``;\n    }\n    return `${innerExpr} ${operation} \\`${model.params[0]}\\``;\n  };\n}\n\nfunction getRangeVectorParamDef(): QueryBuilderOperationParamDef {\n  return {\n    name: 'Range',\n    type: 'string',\n    options: ['$__interval', '$__range', '1m', '5m', '10m', '1h', '24h'],\n  };\n}\n","import {\n  createAggregationOperation,\n  createAggregationOperationWithParam,\n} from '../../prometheus/querybuilder/shared/operationUtils';\nimport { QueryBuilderOperationDef, QueryBuilderOperationParamValue } from '../../prometheus/querybuilder/shared/types';\n\nimport { binaryScalarOperations } from './binaryScalarOperations';\nimport { UnwrapParamEditor } from './components/UnwrapParamEditor';\nimport {\n  addLokiOperation,\n  addNestedQueryHandler,\n  createRangeOperation,\n  createRangeOperationWithGrouping,\n  getLineFilterRenderer,\n  labelFilterRenderer,\n  pipelineRenderer,\n} from './operationUtils';\nimport { LokiOperationId, LokiOperationOrder, LokiVisualQueryOperationCategory } from './types';\n\nexport function getOperationDefinitions(): QueryBuilderOperationDef[] {\n  const aggregations = [\n    LokiOperationId.Sum,\n    LokiOperationId.Min,\n    LokiOperationId.Max,\n    LokiOperationId.Avg,\n    LokiOperationId.Stddev,\n    LokiOperationId.Stdvar,\n    LokiOperationId.Count,\n  ].flatMap((opId) =>\n    createAggregationOperation(opId, {\n      addOperationHandler: addLokiOperation,\n      orderRank: LokiOperationOrder.Last,\n    })\n  );\n\n  const aggregationsWithParam = [LokiOperationId.TopK, LokiOperationId.BottomK].flatMap((opId) => {\n    return createAggregationOperationWithParam(\n      opId,\n      {\n        params: [{ name: 'K-value', type: 'number' }],\n        defaultParams: [5],\n      },\n      {\n        addOperationHandler: addLokiOperation,\n        orderRank: LokiOperationOrder.Last,\n      }\n    );\n  });\n\n  const rangeOperations = [\n    createRangeOperation(LokiOperationId.Rate),\n    createRangeOperation(LokiOperationId.RateCounter),\n    createRangeOperation(LokiOperationId.CountOverTime),\n    createRangeOperation(LokiOperationId.SumOverTime),\n    createRangeOperation(LokiOperationId.BytesRate),\n    createRangeOperation(LokiOperationId.BytesOverTime),\n    createRangeOperation(LokiOperationId.AbsentOverTime),\n  ];\n\n  const rangeOperationsWithGrouping = [\n    ...createRangeOperationWithGrouping(LokiOperationId.AvgOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.MaxOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.MinOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.FirstOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.LastOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.StdvarOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.StddevOverTime),\n    ...createRangeOperationWithGrouping(LokiOperationId.QuantileOverTime),\n  ];\n\n  const list: QueryBuilderOperationDef[] = [\n    ...aggregations,\n    ...aggregationsWithParam,\n    ...rangeOperations,\n    ...rangeOperationsWithGrouping,\n    {\n      id: LokiOperationId.Json,\n      name: 'Json',\n      params: [\n        {\n          name: 'Expression',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          minWidth: 18,\n          placeholder: 'server=\"servers[0]\"',\n          description:\n            'Using expressions with your json parser will extract only the specified json fields to labels. You can specify one or more expressions in this way. All expressions must be quoted.',\n        },\n      ],\n      defaultParams: [],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | json ${model.params.join(', ')}`.trim(),\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will extract keys and values from a [json](https://grafana.com/docs/loki/latest/logql/log_queries/#json) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Logfmt,\n      name: 'Logfmt',\n      params: [],\n      defaultParams: [],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: pipelineRenderer,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will extract all keys and values from a [logfmt](https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Regexp,\n      name: 'Regexp',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: '<re>',\n          description: 'The regexp expression that matches the structure of a log line.',\n          minWidth: 20,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | regexp \\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `The [regexp parser](https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression) takes a single parameter | regexp \"<re>\" which is the regular expression using the Golang RE2 syntax. The regular expression must contain a least one named sub-match (e.g (?P<name>re)), each sub-match will extract a different label. The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Pattern,\n      name: 'Pattern',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: '<pattern-expression>',\n          description: 'The expression that matches the structure of a log line.',\n          minWidth: 20,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | pattern \\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `The [pattern parser](https://grafana.com/docs/loki/latest/logql/log_queries/#pattern) allows the explicit extraction of fields from log lines by defining a pattern expression (| pattern \\`<pattern-expression>\\`). The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Unpack,\n      name: 'Unpack',\n      params: [],\n      defaultParams: [],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: pipelineRenderer,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will extract all keys and values from a JSON log line, [unpacking](https://grafana.com/docs/loki/latest/logql/log_queries/#unpack) all embedded labels in the pack stage. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.LineFormat,\n      name: 'Line format',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: '{{.status_code}}',\n          description: 'A line template that can refer to stream labels and extracted labels.',\n          minWidth: 20,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | line_format \\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will replace log line using a specified template. The template can refer to stream labels and extracted labels.\n\nExample: \\`{{.status_code}} - {{.message}}\\`\n\n[Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#line-format-expression) for more.\n        `,\n    },\n    {\n      id: LokiOperationId.LabelFormat,\n      name: 'Label format',\n      params: [\n        { name: 'Label', type: 'string' },\n        { name: 'Rename to', type: 'string' },\n      ],\n      defaultParams: ['', ''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | label_format ${model.params[1]}=${model.params[0]}`,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will change name of label to desired new label. In the example below, label \"error_level\" will be renamed to \"level\".\n\nExample: \\`\\`error_level=\\`level\\` \\`\\`\n\n[Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#labels-format-expression) for more.\n        `,\n    },\n\n    {\n      id: LokiOperationId.LineContains,\n      name: 'Line contains',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Text to find',\n          description: 'Find log lines that contains this text',\n          minWidth: 20,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('|='),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that contain string \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineContainsNot,\n      name: 'Line does not contain',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Text to exclude',\n          description: 'Find log lines that does not contain this text',\n          minWidth: 26,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('!='),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that does not contain string \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineContainsCaseInsensitive,\n      name: 'Line contains case insensitive',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Text to find',\n          description: 'Find log lines that contains this text',\n          minWidth: 33,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('|~', true),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that match regex \\`(?i)${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineContainsNotCaseInsensitive,\n      name: 'Line does not contain case insensitive',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Text to exclude',\n          description: 'Find log lines that does not contain this text',\n          minWidth: 40,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('!~', true),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that does not match regex \\`(?i)${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineMatchesRegex,\n      name: 'Line contains regex match',\n      params: [\n        {\n          name: 'Regex',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Pattern to match',\n          description: 'Find log lines that match this regex pattern',\n          minWidth: 30,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('|~'),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that match a \\`RE2\\` regex pattern. \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineMatchesRegexNot,\n      name: 'Line does not match regex',\n      params: [\n        {\n          name: 'Regex',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Pattern to exclude',\n          description: 'Find log lines that does not match this regex pattern',\n          minWidth: 30,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('!~'),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that doesn't match a \\`RE2\\` regex pattern. \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineFilterIpMatches,\n      name: 'IP line filter expression',\n      params: [\n        { name: 'Operator', type: 'string', options: ['|=', '!='] },\n        {\n          name: 'Pattern',\n          type: 'string',\n          placeholder: '<pattern>',\n          minWidth: 16,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: ['|=', ''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: (op, def, innerExpr) => `${innerExpr} ${op.params[0]} ip(\\`${op.params[1]}\\`)`,\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines using IP matching of \\`${op.params[1]}\\``,\n    },\n    {\n      id: LokiOperationId.LabelFilter,\n      name: 'Label filter expression',\n      params: [\n        { name: 'Label', type: 'string' },\n        { name: 'Operator', type: 'string', options: ['=', '!=', ' =~', '!~', '>', '<', '>=', '<='] },\n        { name: 'Value', type: 'string' },\n      ],\n      defaultParams: ['', '=', ''],\n      alternativesKey: 'label filter',\n      category: LokiVisualQueryOperationCategory.LabelFilters,\n      orderRank: LokiOperationOrder.LabelFilters,\n      renderer: labelFilterRenderer,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () => `Label expression filter allows filtering using original and extracted labels.`,\n    },\n    {\n      id: LokiOperationId.LabelFilterIpMatches,\n      name: 'IP label filter expression',\n      params: [\n        { name: 'Label', type: 'string' },\n        { name: 'Operator', type: 'string', options: ['=', '!='] },\n        { name: 'Value', type: 'string' },\n      ],\n      defaultParams: ['', '=', ''],\n      alternativesKey: 'label filter',\n      category: LokiVisualQueryOperationCategory.LabelFilters,\n      orderRank: LokiOperationOrder.LabelFilters,\n      renderer: (model, def, innerExpr) =>\n        `${innerExpr} | ${model.params[0]} ${model.params[1]} ip(\\`${model.params[2]}\\`)`,\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines using IP matching of \\`${op.params[2]}\\` for \\`${op.params[0]}\\` label`,\n    },\n    {\n      id: LokiOperationId.LabelFilterNoErrors,\n      name: 'No pipeline errors',\n      params: [],\n      defaultParams: [],\n      alternativesKey: 'label filter',\n      category: LokiVisualQueryOperationCategory.LabelFilters,\n      orderRank: LokiOperationOrder.NoErrors,\n      renderer: (model, def, innerExpr) => `${innerExpr} | __error__=\\`\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () => `Filter out all formatting and parsing errors.`,\n    },\n    {\n      id: LokiOperationId.Unwrap,\n      name: 'Unwrap',\n      params: [\n        {\n          name: 'Identifier',\n          type: 'string',\n          hideName: true,\n          minWidth: 16,\n          placeholder: 'Label key',\n          editor: UnwrapParamEditor,\n        },\n        {\n          name: 'Conversion function',\n          hideName: true,\n          type: 'string',\n          options: ['duration', 'duration_seconds', 'bytes'],\n          optional: true,\n        },\n      ],\n      defaultParams: ['', ''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.Unwrap,\n      renderer: (op, def, innerExpr) =>\n        `${innerExpr} | unwrap ${op.params[1] ? `${op.params[1]}(${op.params[0]})` : op.params[0]}`,\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => {\n        let label = String(op.params[0]).length > 0 ? op.params[0] : '<label>';\n        return `Use the extracted label \\`${label}\\` as sample values instead of log lines for the subsequent range aggregation.${\n          op.params[1]\n            ? ` Conversion function \\`${op.params[1]}\\` wrapping \\`${label}\\` will attempt to convert this label from a specific format (e.g. 3k, 500ms).`\n            : ''\n        }`;\n      },\n    },\n    ...binaryScalarOperations,\n    {\n      id: LokiOperationId.NestedQuery,\n      name: 'Binary operation with query',\n      params: [],\n      defaultParams: [],\n      category: LokiVisualQueryOperationCategory.BinaryOps,\n      renderer: (model, def, innerExpr) => innerExpr,\n      addOperationHandler: addNestedQueryHandler,\n    },\n  ];\n\n  return list;\n}\n\n// Keeping a local copy as an optimization measure.\nconst definitions = getOperationDefinitions();\n\n/**\n * Given an operator, return the corresponding explain.\n * For usage within the Query Editor.\n */\nexport function explainOperator(id: LokiOperationId | string): string {\n  const definition = definitions.find((operation) => operation.id === id);\n\n  const explain = definition?.explainHandler?.({ id: '', params: ['<value>'] }) || '';\n\n  // Strip markdown links\n  return explain.replace(/\\[(.*)\\]\\(.*\\)/g, '$1');\n}\n\nexport function getDefinitionById(id: string): QueryBuilderOperationDef | undefined {\n  return definitions.find((x) => x.id === id);\n}\n\nexport function checkParamsAreValid(def: QueryBuilderOperationDef, params: QueryBuilderOperationParamValue[]): boolean {\n  // For now we only check if the operation has all the required params.\n  if (params.length < def.params.filter((param) => !param.optional).length) {\n    return false;\n  }\n\n  return true;\n}\n","import { SyntaxNode } from '@lezer/common';\nimport { BinModifiers, OnOrIgnoring } from '@prometheus-io/lezer-promql';\n\nimport {\n  And,\n  BinOpExpr,\n  Bool,\n  By,\n  ConvOp,\n  Filter,\n  FilterOp,\n  Grouping,\n  GroupingLabelList,\n  GroupingLabels,\n  Identifier,\n  Ip,\n  IpLabelFilter,\n  Json,\n  JsonExpression,\n  JsonExpressionParser,\n  LabelFilter,\n  LabelFormatMatcher,\n  LabelParser,\n  LineFilter,\n  LineFormatExpr,\n  LogRangeExpr,\n  Matcher,\n  MetricExpr,\n  Number as NumberLezer,\n  On,\n  Or,\n  parser,\n  Range,\n  RangeAggregationExpr,\n  RangeOp,\n  String,\n  UnitFilter,\n  Unwrap,\n  UnwrapExpr,\n  VectorAggregationExpr,\n  VectorOp,\n  Without,\n} from '@grafana/lezer-logql';\n\nimport {\n  ErrorId,\n  getAllByType,\n  getLeftMostChild,\n  getString,\n  makeBinOp,\n  makeError,\n  replaceVariables,\n} from '../../prometheus/querybuilder/shared/parsingUtils';\nimport {\n  QueryBuilderLabelFilter,\n  QueryBuilderOperation,\n  QueryBuilderOperationParamValue,\n} from '../../prometheus/querybuilder/shared/types';\n\nimport { binaryScalarDefs } from './binaryScalarOperations';\nimport { checkParamsAreValid, getDefinitionById } from './operations';\nimport { LokiOperationId, LokiVisualQuery, LokiVisualQueryBinary } from './types';\n\ninterface Context {\n  query: LokiVisualQuery;\n  errors: ParsingError[];\n}\n\ninterface ParsingError {\n  text: string;\n  from?: number;\n  to?: number;\n  parentType?: string;\n}\n\nexport function buildVisualQueryFromString(expr: string): Context {\n  const replacedExpr = replaceVariables(expr);\n  const tree = parser.parse(replacedExpr);\n  const node = tree.topNode;\n\n  // This will be modified in the handleExpression\n  const visQuery: LokiVisualQuery = {\n    labels: [],\n    operations: [],\n  };\n\n  const context: Context = {\n    query: visQuery,\n    errors: [],\n  };\n\n  try {\n    handleExpression(replacedExpr, node, context);\n  } catch (err) {\n    // Not ideal to log it here, but otherwise we would lose the stack trace.\n    console.error(err);\n    if (err instanceof Error) {\n      context.errors.push({\n        text: err.message,\n      });\n    }\n  }\n\n  // If we have empty query, we want to reset errors\n  if (isEmptyQuery(context.query)) {\n    context.errors = [];\n  }\n  return context;\n}\n\nexport function handleExpression(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  switch (node.type.id) {\n    case Matcher: {\n      visQuery.labels.push(getLabel(expr, node));\n      const err = node.getChild(ErrorId);\n      if (err) {\n        context.errors.push(makeError(expr, err));\n      }\n      break;\n    }\n\n    case LineFilter: {\n      const { operation, error } = getLineFilter(expr, node);\n      if (operation) {\n        visQuery.operations.push(operation);\n      }\n      // Show error for query patterns not supported in visual query builder\n      if (error) {\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n      break;\n    }\n\n    case LabelParser: {\n      visQuery.operations.push(getLabelParser(expr, node));\n      break;\n    }\n\n    case LabelFilter: {\n      const { operation, error } = getLabelFilter(expr, node);\n      if (operation) {\n        visQuery.operations.push(operation);\n      }\n      // Show error for query patterns not supported in visual query builder\n      if (error) {\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n      break;\n    }\n    case JsonExpressionParser: {\n      visQuery.operations.push(getJsonExpressionParser(expr, node));\n      break;\n    }\n\n    case LineFormatExpr: {\n      visQuery.operations.push(getLineFormat(expr, node));\n      break;\n    }\n\n    case LabelFormatMatcher: {\n      visQuery.operations.push(getLabelFormat(expr, node));\n      break;\n    }\n\n    case UnwrapExpr: {\n      const { operation, error } = handleUnwrapExpr(expr, node, context);\n      if (operation) {\n        visQuery.operations.push(operation);\n      }\n      // Show error for query patterns not supported in visual query builder\n      if (error) {\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n\n      break;\n    }\n\n    case RangeAggregationExpr: {\n      visQuery.operations.push(handleRangeAggregation(expr, node, context));\n      break;\n    }\n\n    case VectorAggregationExpr: {\n      visQuery.operations.push(handleVectorAggregation(expr, node, context));\n      break;\n    }\n\n    case BinOpExpr: {\n      handleBinary(expr, node, context);\n      break;\n    }\n\n    case ErrorId: {\n      if (isIntervalVariableError(node)) {\n        break;\n      }\n      context.errors.push(makeError(expr, node));\n      break;\n    }\n\n    default: {\n      // Any other nodes we just ignore and go to its children. This should be fine as there are lots of wrapper\n      // nodes that can be skipped.\n      // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to\n      //  detect those and report back.\n      let child = node.firstChild;\n      while (child) {\n        handleExpression(expr, child, context);\n        child = child.nextSibling;\n      }\n    }\n  }\n}\n\nfunction getLabel(expr: string, node: SyntaxNode): QueryBuilderLabelFilter {\n  const labelNode = node.getChild(Identifier);\n  const label = getString(expr, labelNode);\n  const op = getString(expr, labelNode!.nextSibling);\n  let value = getString(expr, node.getChild(String));\n  // `value` is wrapped in double quotes, so we need to remove them. As a value can contain double quotes, we can't use RegEx here.\n  value = value.substring(1, value.length - 1);\n\n  return {\n    label,\n    op,\n    value,\n  };\n}\n\nfunction getLineFilter(expr: string, node: SyntaxNode): { operation?: QueryBuilderOperation; error?: string } {\n  const filter = getString(expr, node.getChild(Filter));\n  const filterExpr = handleQuotes(getString(expr, node.getChild(String)));\n  const ipLineFilter = node.getChild(FilterOp)?.getChild(Ip);\n\n  if (ipLineFilter) {\n    return {\n      operation: {\n        id: LokiOperationId.LineFilterIpMatches,\n        params: [filter, filterExpr],\n      },\n    };\n  }\n  const mapFilter: any = {\n    '|=': LokiOperationId.LineContains,\n    '!=': LokiOperationId.LineContainsNot,\n    '|~': LokiOperationId.LineMatchesRegex,\n    '!~': LokiOperationId.LineMatchesRegexNot,\n  };\n\n  return {\n    operation: {\n      id: mapFilter[filter],\n      params: [filterExpr],\n    },\n  };\n}\n\nfunction getLabelParser(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const parserNode = node.firstChild;\n  const parser = getString(expr, parserNode);\n\n  const string = handleQuotes(getString(expr, node.getChild(String)));\n  let params: QueryBuilderOperationParamValue[] = !!string ? [string] : [];\n  const opDef = getDefinitionById(parser);\n  if (opDef && !checkParamsAreValid(opDef, params)) {\n    params = opDef?.defaultParams || [];\n  }\n\n  return {\n    id: parser,\n    params,\n  };\n}\n\nfunction getJsonExpressionParser(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const parserNode = node.getChild(Json);\n  const parser = getString(expr, parserNode);\n\n  const params = [...getAllByType(expr, node, JsonExpression)];\n  return {\n    id: parser,\n    params,\n  };\n}\n\nfunction getLabelFilter(expr: string, node: SyntaxNode): { operation?: QueryBuilderOperation; error?: string } {\n  // Check for nodes not supported in visual builder and return error\n  if (node.getChild(Or) || node.getChild(And) || node.getChild('Comma')) {\n    return {\n      error: 'Label filter with comma, \"and\", \"or\" not supported in query builder',\n    };\n  }\n  if (node.firstChild!.type.id === IpLabelFilter) {\n    const ipLabelFilter = node.firstChild;\n    const label = ipLabelFilter?.getChild(Identifier);\n    const op = label?.nextSibling;\n    const value = ipLabelFilter?.getChild(String);\n    const valueString = handleQuotes(getString(expr, value));\n\n    return {\n      operation: {\n        id: LokiOperationId.LabelFilterIpMatches,\n        params: [getString(expr, label), getString(expr, op), valueString],\n      },\n    };\n  }\n\n  const id = LokiOperationId.LabelFilter;\n  if (node.firstChild!.type.id === UnitFilter) {\n    const filter = node.firstChild!.firstChild;\n    const label = filter!.firstChild;\n    const op = label!.nextSibling;\n    const value = op!.nextSibling;\n    const valueString = handleQuotes(getString(expr, value));\n\n    return {\n      operation: {\n        id,\n        params: [getString(expr, label), getString(expr, op), valueString],\n      },\n    };\n  }\n  // In this case it is Matcher or NumberFilter\n  const filter = node.firstChild;\n  const label = filter!.firstChild;\n  const op = label!.nextSibling;\n  const value = op!.nextSibling;\n  const params = [getString(expr, label), getString(expr, op), handleQuotes(getString(expr, value))];\n\n  // Special case of pipe filtering - no errors\n  if (params.join('') === `__error__=`) {\n    return {\n      operation: {\n        id: LokiOperationId.LabelFilterNoErrors,\n        params: [],\n      },\n    };\n  }\n\n  return {\n    operation: {\n      id,\n      params,\n    },\n  };\n}\n\nfunction getLineFormat(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const id = LokiOperationId.LineFormat;\n  const string = handleQuotes(getString(expr, node.getChild(String)));\n\n  return {\n    id,\n    params: [string],\n  };\n}\n\nfunction getLabelFormat(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const id = LokiOperationId.LabelFormat;\n  const renameTo = node.getChild(Identifier);\n  const op = renameTo!.nextSibling;\n  const originalLabel = op!.nextSibling;\n\n  return {\n    id,\n    params: [getString(expr, originalLabel), handleQuotes(getString(expr, renameTo))],\n  };\n}\n\nfunction handleUnwrapExpr(\n  expr: string,\n  node: SyntaxNode,\n  context: Context\n): { operation?: QueryBuilderOperation; error?: string } {\n  const unwrapExprChild = node.getChild(UnwrapExpr);\n  const labelFilterChild = node.getChild(LabelFilter);\n  const unwrapChild = node.getChild(Unwrap);\n\n  if (unwrapExprChild) {\n    handleExpression(expr, unwrapExprChild, context);\n  }\n\n  if (labelFilterChild) {\n    handleExpression(expr, labelFilterChild, context);\n  }\n\n  if (unwrapChild) {\n    if (unwrapChild.nextSibling?.type.id === ConvOp) {\n      const convOp = unwrapChild.nextSibling;\n      const identifier = convOp.nextSibling;\n      return {\n        operation: {\n          id: LokiOperationId.Unwrap,\n          params: [getString(expr, identifier), getString(expr, convOp)],\n        },\n      };\n    }\n\n    return {\n      operation: {\n        id: LokiOperationId.Unwrap,\n        params: [getString(expr, unwrapChild?.nextSibling), ''],\n      },\n    };\n  }\n\n  return {};\n}\nfunction handleRangeAggregation(expr: string, node: SyntaxNode, context: Context) {\n  const nameNode = node.getChild(RangeOp);\n  const funcName = getString(expr, nameNode);\n  const number = node.getChild(NumberLezer);\n  const logExpr = node.getChild(LogRangeExpr);\n  const params = number !== null && number !== undefined ? [getString(expr, number)] : [];\n  const range = logExpr?.getChild(Range);\n  const rangeValue = range ? getString(expr, range) : null;\n\n  if (rangeValue) {\n    params.unshift(rangeValue.substring(1, rangeValue.length - 1));\n  }\n\n  const op = {\n    id: funcName,\n    params,\n  };\n\n  if (logExpr) {\n    handleExpression(expr, logExpr, context);\n  }\n\n  return op;\n}\n\nfunction handleVectorAggregation(expr: string, node: SyntaxNode, context: Context) {\n  const nameNode = node.getChild(VectorOp);\n  let funcName = getString(expr, nameNode);\n\n  const grouping = node.getChild(Grouping);\n  const params = [];\n\n  const numberNode = node.getChild(NumberLezer);\n\n  if (numberNode) {\n    params.push(Number(getString(expr, numberNode)));\n  }\n\n  if (grouping) {\n    const byModifier = grouping.getChild(By);\n    if (byModifier && funcName) {\n      funcName = `__${funcName}_by`;\n    }\n\n    const withoutModifier = grouping.getChild(Without);\n    if (withoutModifier) {\n      funcName = `__${funcName}_without`;\n    }\n\n    params.push(...getAllByType(expr, grouping, Identifier));\n  }\n\n  const metricExpr = node.getChild(MetricExpr);\n  const op: QueryBuilderOperation = { id: funcName, params };\n\n  if (metricExpr) {\n    handleExpression(expr, metricExpr, context);\n  }\n\n  return op;\n}\n\nconst operatorToOpName = binaryScalarDefs.reduce((acc, def) => {\n  acc[def.sign] = {\n    id: def.id,\n    comparison: def.comparison,\n  };\n  return acc;\n}, {} as Record<string, { id: string; comparison?: boolean }>);\n\n/**\n * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is\n * just operation with scalar or it creates a binaryQuery when it's 2 queries.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleBinary(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const left = node.firstChild!;\n  const op = getString(expr, left.nextSibling);\n  const binModifier = getBinaryModifier(expr, node.getChild(BinModifiers));\n\n  const right = node.lastChild!;\n\n  const opDef = operatorToOpName[op];\n\n  const leftNumber = getLastChildWithSelector(left, 'MetricExpr.LiteralExpr.Number');\n  const rightNumber = getLastChildWithSelector(right, 'MetricExpr.LiteralExpr.Number');\n\n  const rightBinary = right.getChild(BinOpExpr);\n\n  if (leftNumber) {\n    // TODO: this should be already handled in case parent is binary expression as it has to be added to parent\n    //  if query starts with a number that isn't handled now.\n  } else {\n    // If this is binary we don't really know if there is a query or just chained scalars. So\n    // we have to traverse a bit deeper to know\n    handleExpression(expr, left, context);\n  }\n\n  if (rightNumber) {\n    visQuery.operations.push(makeBinOp(opDef, expr, right, !!binModifier?.isBool));\n  } else if (rightBinary) {\n    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which\n    // is a factor for a current binary operation. So we have to add it as an operation now.\n    const leftMostChild = getLeftMostChild(right);\n    if (leftMostChild?.name === 'Number') {\n      visQuery.operations.push(makeBinOp(opDef, expr, leftMostChild, !!binModifier?.isBool));\n    }\n\n    // If we added the first number literal as operation here we still can continue and handle the rest as the first\n    // number will be just skipped.\n    handleExpression(expr, right, context);\n  } else {\n    visQuery.binaryQueries = visQuery.binaryQueries || [];\n    const binQuery: LokiVisualQueryBinary = {\n      operator: op,\n      query: {\n        labels: [],\n        operations: [],\n      },\n    };\n    if (binModifier?.isMatcher) {\n      binQuery.vectorMatchesType = binModifier.matchType;\n      binQuery.vectorMatches = binModifier.matches;\n    }\n    visQuery.binaryQueries.push(binQuery);\n    handleExpression(expr, right, {\n      query: binQuery.query,\n      errors: context.errors,\n    });\n  }\n}\n\nfunction getBinaryModifier(\n  expr: string,\n  node: SyntaxNode | null\n):\n  | { isBool: true; isMatcher: false }\n  | { isBool: false; isMatcher: true; matches: string; matchType: 'ignoring' | 'on' }\n  | undefined {\n  if (!node) {\n    return undefined;\n  }\n  if (node.getChild(Bool)) {\n    return { isBool: true, isMatcher: false };\n  } else {\n    const matcher = node.getChild(OnOrIgnoring);\n    if (!matcher) {\n      // Not sure what this could be, maybe should be an error.\n      return undefined;\n    }\n    const labels = getString(expr, matcher.getChild(GroupingLabels)?.getChild(GroupingLabelList));\n    return {\n      isMatcher: true,\n      isBool: false,\n      matches: labels,\n      matchType: matcher.getChild(On) ? 'on' : 'ignoring',\n    };\n  }\n}\n\nfunction isIntervalVariableError(node: SyntaxNode) {\n  return node?.parent?.type.id === Range;\n}\n\nfunction handleQuotes(string: string) {\n  if (string[0] === `\"` && string[string.length - 1] === `\"`) {\n    return string.replace(/\"/g, '').replace(/\\\\\\\\/g, '\\\\');\n  }\n  return string.replace(/`/g, '');\n}\n\n/**\n * Simple helper to traverse the syntax tree. Instead of node.getChild('foo')?.getChild('bar')?.getChild('baz') you\n * can write getChildWithSelector(node, 'foo.bar.baz')\n * @param node\n * @param selector\n */\nfunction getLastChildWithSelector(node: SyntaxNode, selector: string) {\n  let child: SyntaxNode | null = node;\n  const children = selector.split('.');\n  for (const s of children) {\n    child = child.getChild(s);\n    if (!child) {\n      return null;\n    }\n  }\n  return child;\n}\n\n/**\n * Helper function to enrich error text with information that visual query builder doesn't support that logQL\n * @param expr\n * @param node\n * @param error\n */\nfunction createNotSupportedError(expr: string, node: SyntaxNode, error: string) {\n  const err = makeError(expr, node);\n  err.text = `${error}: ${err.text}`;\n  return err;\n}\n\nfunction isEmptyQuery(query: LokiVisualQuery) {\n  if (query.labels.length === 0 && query.operations.length === 0) {\n    return true;\n  }\n  return false;\n}\n","import { VisualQueryBinary } from '../../prometheus/querybuilder/shared/LokiAndPromQueryModellerBase';\nimport { QueryBuilderLabelFilter, QueryBuilderOperation } from '../../prometheus/querybuilder/shared/types';\n\n/**\n * Visual query model\n */\nexport interface LokiVisualQuery {\n  labels: QueryBuilderLabelFilter[];\n  operations: QueryBuilderOperation[];\n  binaryQueries?: LokiVisualQueryBinary[];\n}\n\nexport type LokiVisualQueryBinary = VisualQueryBinary<LokiVisualQuery>;\nexport enum LokiQueryPatternType {\n  Log = 'log',\n  Metric = 'metric',\n}\n\nexport interface LokiQueryPattern {\n  name: string;\n  operations: QueryBuilderOperation[];\n  type: LokiQueryPatternType;\n}\n\nexport enum LokiVisualQueryOperationCategory {\n  Aggregations = 'Aggregations',\n  RangeFunctions = 'Range functions',\n  Functions = 'Functions',\n  Formats = 'Formats',\n  LineFilters = 'Line filters',\n  LabelFilters = 'Label filters',\n  BinaryOps = 'Binary operations',\n}\n\nexport enum LokiOperationId {\n  Json = 'json',\n  Logfmt = 'logfmt',\n  Regexp = 'regexp',\n  Pattern = 'pattern',\n  Unpack = 'unpack',\n  LineFormat = 'line_format',\n  LabelFormat = 'label_format',\n  Rate = 'rate',\n  RateCounter = 'rate_counter',\n  CountOverTime = 'count_over_time',\n  SumOverTime = 'sum_over_time',\n  AvgOverTime = 'avg_over_time',\n  MaxOverTime = 'max_over_time',\n  MinOverTime = 'min_over_time',\n  FirstOverTime = 'first_over_time',\n  LastOverTime = 'last_over_time',\n  StdvarOverTime = 'stdvar_over_time',\n  StddevOverTime = 'stddev_over_time',\n  QuantileOverTime = 'quantile_over_time',\n  BytesRate = 'bytes_rate',\n  BytesOverTime = 'bytes_over_time',\n  AbsentOverTime = 'absent_over_time',\n  Sum = 'sum',\n  Avg = 'avg',\n  Min = 'min',\n  Max = 'max',\n  Stddev = 'stddev',\n  Stdvar = 'stdvar',\n  Count = 'count',\n  TopK = 'topk',\n  BottomK = 'bottomk',\n  LineContains = '__line_contains',\n  LineContainsNot = '__line_contains_not',\n  LineContainsCaseInsensitive = '__line_contains_case_insensitive',\n  LineContainsNotCaseInsensitive = '__line_contains_not_case_insensitive',\n  LineMatchesRegex = '__line_matches_regex',\n  LineMatchesRegexNot = '__line_matches_regex_not',\n  LineFilterIpMatches = '__line_filter_ip_matches',\n  LabelFilter = '__label_filter',\n  LabelFilterNoErrors = '__label_filter_no_errors',\n  LabelFilterIpMatches = '__label_filter_ip_marches',\n  Unwrap = 'unwrap',\n  SumBy = '__sum_by',\n  SumWithout = '__sum_without',\n  // Binary ops\n  Addition = '__addition',\n  Subtraction = '__subtraction',\n  MultiplyBy = '__multiply_by',\n  DivideBy = '__divide_by',\n  Modulo = '__modulo',\n  Exponent = '__exponent',\n  NestedQuery = '__nested_query',\n  EqualTo = '__equal_to',\n  NotEqualTo = '__not_equal_to',\n  GreaterThan = '__greater_than',\n  LessThan = '__less_than',\n  GreaterOrEqual = '__greater_or_equal',\n  LessOrEqual = '__less_or_equal',\n}\n\nexport enum LokiOperationOrder {\n  LineFilters = 1,\n  LineFormats = 2,\n  LabelFilters = 3,\n  Unwrap = 4,\n  NoErrors = 5,\n  RangeVectorFunction = 5,\n  Last = 6,\n}\n","export function isLogLineJSON(line: string): boolean {\n  let parsed;\n  try {\n    parsed = JSON.parse(line);\n  } catch (error) {}\n  // The JSON parser should only be used for log lines that are valid serialized JSON objects.\n  return typeof parsed === 'object';\n}\n\n// This matches:\n// first a label from start of the string or first white space, then any word chars until \"=\"\n// second either an empty quotes, or anything that starts with quote and ends with unescaped quote,\n// or any non whitespace chars that do not start with quote\nconst LOGFMT_REGEXP = /(?:^|\\s)([\\w\\(\\)\\[\\]\\{\\}]+)=(\"\"|(?:\".*?[^\\\\]\"|[^\"\\s]\\S*))/;\n\nexport function isLogLineLogfmt(line: string): boolean {\n  return LOGFMT_REGEXP.test(line);\n}\n","import { DataFrame, FieldType, isValidGoDuration, Labels } from '@grafana/data';\n\nimport { isBytesString } from './languageUtils';\nimport { isLogLineJSON, isLogLineLogfmt } from './lineParser';\n\nexport function dataFrameHasLokiError(frame: DataFrame): boolean {\n  const labelSets: Labels[] = frame.fields.find((f) => f.name === 'labels')?.values.toArray() ?? [];\n  return labelSets.some((labels) => labels.__error__ !== undefined);\n}\n\nexport function dataFrameHasLevelLabel(frame: DataFrame): boolean {\n  const labelSets: Labels[] = frame.fields.find((f) => f.name === 'labels')?.values.toArray() ?? [];\n  return labelSets.some((labels) => labels.level !== undefined);\n}\n\nexport function extractLogParserFromDataFrame(frame: DataFrame): { hasLogfmt: boolean; hasJSON: boolean } {\n  const lineField = frame.fields.find((field) => field.type === FieldType.string);\n  if (lineField == null) {\n    return { hasJSON: false, hasLogfmt: false };\n  }\n\n  const logLines: string[] = lineField.values.toArray();\n\n  let hasJSON = false;\n  let hasLogfmt = false;\n\n  logLines.forEach((line) => {\n    if (isLogLineJSON(line)) {\n      hasJSON = true;\n    }\n    if (isLogLineLogfmt(line)) {\n      hasLogfmt = true;\n    }\n  });\n\n  return { hasLogfmt, hasJSON };\n}\n\nexport function extractLabelKeysFromDataFrame(frame: DataFrame): string[] {\n  const labelsArray: Array<{ [key: string]: string }> | undefined =\n    frame?.fields?.find((field) => field.name === 'labels')?.values.toArray() ?? [];\n\n  if (!labelsArray?.length) {\n    return [];\n  }\n\n  return Object.keys(labelsArray[0]);\n}\n\nexport function extractUnwrapLabelKeysFromDataFrame(frame: DataFrame): string[] {\n  const labelsArray: Array<{ [key: string]: string }> | undefined =\n    frame?.fields?.find((field) => field.name === 'labels')?.values.toArray() ?? [];\n\n  if (!labelsArray?.length) {\n    return [];\n  }\n\n  // We do this only for first label object, because we want to consider only labels that are present in all log lines\n  // possibleUnwrapLabels are labels with 1. number value OR 2. value that is valid go duration OR 3. bytes string value\n  const possibleUnwrapLabels = Object.keys(labelsArray[0]).filter((key) => {\n    const value = labelsArray[0][key];\n    if (!value) {\n      return false;\n    }\n    return !isNaN(Number(value)) || isValidGoDuration(value) || isBytesString(value);\n  });\n\n  // Add only labels that are present in every line to unwrapLabels\n  return possibleUnwrapLabels.filter((label) => labelsArray.every((obj) => obj[label]));\n}\n\nexport function extractHasErrorLabelFromDataFrame(frame: DataFrame): boolean {\n  const labelField = frame.fields.find((field) => field.name === 'labels' && field.type === FieldType.other);\n  if (labelField == null) {\n    return false;\n  }\n\n  const labels: Array<{ [key: string]: string }> = labelField.values.toArray();\n  return labels.some((label) => label['__error__']);\n}\n\nexport function extractLevelLikeLabelFromDataFrame(frame: DataFrame): string | null {\n  const labelField = frame.fields.find((field) => field.name === 'labels' && field.type === FieldType.other);\n  if (labelField == null) {\n    return null;\n  }\n\n  // Depending on number of labels, this can be pretty heavy operation.\n  // Let's just look at first 2 lines If needed, we can introduce more later.\n  const labelsArray: Array<{ [key: string]: string }> = labelField.values.toArray().slice(0, 2);\n  let levelLikeLabel: string | null = null;\n\n  // Find first level-like label\n  for (let labels of labelsArray) {\n    const label = Object.keys(labels).find((label) => label === 'lvl' || label.includes('level'));\n    if (label) {\n      levelLikeLabel = label;\n      break;\n    }\n  }\n  return levelLikeLabel;\n}\n","import { Grammar } from 'prismjs';\n\nimport { CompletionItem } from '@grafana/ui';\n\nexport const AGGREGATION_OPERATORS: CompletionItem[] = [\n  {\n    label: 'avg',\n    insertText: 'avg',\n    documentation: 'Calculate the average over dimensions',\n  },\n  {\n    label: 'bottomk',\n    insertText: 'bottomk',\n    documentation: 'Smallest k elements by sample value',\n  },\n  {\n    label: 'count',\n    insertText: 'count',\n    documentation: 'Count number of elements in the vector',\n  },\n  {\n    label: 'max',\n    insertText: 'max',\n    documentation: 'Select maximum over dimensions',\n  },\n  {\n    label: 'min',\n    insertText: 'min',\n    documentation: 'Select minimum over dimensions',\n  },\n  {\n    label: 'stddev',\n    insertText: 'stddev',\n    documentation: 'Calculate population standard deviation over dimensions',\n  },\n  {\n    label: 'stdvar',\n    insertText: 'stdvar',\n    documentation: 'Calculate population standard variance over dimensions',\n  },\n  {\n    label: 'sum',\n    insertText: 'sum',\n    documentation: 'Calculate sum over dimensions',\n  },\n  {\n    label: 'topk',\n    insertText: 'topk',\n    documentation: 'Largest k elements by sample value',\n  },\n];\n\nexport const PIPE_PARSERS: CompletionItem[] = [\n  {\n    label: 'json',\n    insertText: 'json',\n    documentation: 'Extracting labels from the log line using json parser.',\n  },\n  {\n    label: 'regexp',\n    insertText: 'regexp \"\"',\n    documentation: 'Extracting labels from the log line using regexp parser.',\n    move: -1,\n  },\n  {\n    label: 'logfmt',\n    insertText: 'logfmt',\n    documentation: 'Extracting labels from the log line using logfmt parser.',\n  },\n  {\n    label: 'pattern',\n    insertText: 'pattern',\n    documentation: 'Extracting labels from the log line using pattern parser. Only available in Loki 2.3+.',\n  },\n  {\n    label: 'unpack',\n    insertText: 'unpack',\n    detail: 'unpack identifier',\n    documentation:\n      'Parses a JSON log line, unpacking all embedded labels in the pack stage. A special property \"_entry\" will also be used to replace the original log line. Only available in Loki 2.2+.',\n  },\n];\n\nexport const PIPE_OPERATORS: CompletionItem[] = [\n  {\n    label: 'unwrap',\n    insertText: 'unwrap',\n    detail: 'unwrap identifier',\n    documentation: 'Take labels and use the values as sample data for metric aggregations.',\n  },\n  {\n    label: 'label_format',\n    insertText: 'label_format',\n    documentation: 'Use to rename, modify or add labels. For example, | label_format foo=bar .',\n  },\n  {\n    label: 'line_format',\n    insertText: 'line_format',\n    documentation: 'Rewrites log line content. For example, | line_format \"{{.query}} {{.duration}}\" .',\n  },\n];\n\nexport const RANGE_VEC_FUNCTIONS = [\n  {\n    insertText: 'avg_over_time',\n    label: 'avg_over_time',\n    detail: 'avg_over_time(range-vector)',\n    documentation: 'The average of all values in the specified interval.',\n  },\n  {\n    insertText: 'bytes_over_time',\n    label: 'bytes_over_time',\n    detail: 'bytes_over_time(range-vector)',\n    documentation: 'Counts the amount of bytes used by each log stream for a given range',\n  },\n  {\n    insertText: 'bytes_rate',\n    label: 'bytes_rate',\n    detail: 'bytes_rate(range-vector)',\n    documentation: 'Calculates the number of bytes per second for each stream.',\n  },\n  {\n    insertText: 'first_over_time',\n    label: 'first_over_time',\n    detail: 'first_over_time(range-vector)',\n    documentation: 'The first of all values in the specified interval. Only available in Loki 2.3+.',\n  },\n  {\n    insertText: 'last_over_time',\n    label: 'last_over_time',\n    detail: 'last_over_time(range-vector)',\n    documentation: 'The last of all values in the specified interval. Only available in Loki 2.3+.',\n  },\n  {\n    insertText: 'sum_over_time',\n    label: 'sum_over_time',\n    detail: 'sum_over_time(range-vector)',\n    documentation: 'The sum of all values in the specified interval.',\n  },\n  {\n    insertText: 'count_over_time',\n    label: 'count_over_time',\n    detail: 'count_over_time(range-vector)',\n    documentation: 'The count of all values in the specified interval.',\n  },\n  {\n    insertText: 'max_over_time',\n    label: 'max_over_time',\n    detail: 'max_over_time(range-vector)',\n    documentation: 'The maximum of all values in the specified interval.',\n  },\n  {\n    insertText: 'min_over_time',\n    label: 'min_over_time',\n    detail: 'min_over_time(range-vector)',\n    documentation: 'The minimum of all values in the specified interval.',\n  },\n  {\n    insertText: 'quantile_over_time',\n    label: 'quantile_over_time',\n    detail: 'quantile_over_time(scalar, range-vector)',\n    documentation: 'The -quantile (0    1) of the values in the specified interval.',\n  },\n  {\n    insertText: 'rate',\n    label: 'rate',\n    detail: 'rate(v range-vector)',\n    documentation: 'Calculates the number of entries per second.',\n  },\n  {\n    insertText: 'stddev_over_time',\n    label: 'stddev_over_time',\n    detail: 'stddev_over_time(range-vector)',\n    documentation: 'The population standard deviation of the values in the specified interval.',\n  },\n  {\n    insertText: 'stdvar_over_time',\n    label: 'stdvar_over_time',\n    detail: 'stdvar_over_time(range-vector)',\n    documentation: 'The population standard variance of the values in the specified interval.',\n  },\n];\n\nexport const FUNCTIONS = [...AGGREGATION_OPERATORS, ...RANGE_VEC_FUNCTIONS];\nexport const LOKI_KEYWORDS = [...FUNCTIONS, ...PIPE_OPERATORS, ...PIPE_PARSERS].map((keyword) => keyword.label);\n\nexport const lokiGrammar: Grammar = {\n  comment: {\n    pattern: /#.*/,\n  },\n  'context-aggregation': {\n    pattern: /((without|by)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^(),\\s][^,)]*[^),\\s]*/,\n        alias: 'attr-name',\n      },\n      punctuation: /[()]/,\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=}?)/,\n    greedy: true,\n    inside: {\n      comment: {\n        pattern: /#.*/,\n      },\n      'label-key': {\n        pattern: /[a-zA-Z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n        greedy: true,\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  'context-pipe': {\n    pattern: /\\s\\|[^=~]\\s?\\w*/i,\n    inside: {\n      'pipe-operator': {\n        pattern: /\\|/i,\n        alias: 'operator',\n      },\n      'pipe-operations': {\n        pattern: new RegExp(`${[...PIPE_PARSERS, ...PIPE_OPERATORS].map((f) => f.label).join('|')}`, 'i'),\n        alias: 'keyword',\n      },\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map((f) => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=\\])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  quote: {\n    pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n    alias: 'string',\n    greedy: true,\n  },\n  backticks: {\n    pattern: /`(?:\\\\.|[^\\\\`])*`/,\n    alias: 'string',\n    greedy: true,\n  },\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: /\\s?(\\|[=~]?|!=?|<(?:=>?|<|>)?|>[>=]?)\\s?/i,\n  punctuation: /[{}(),.]/,\n};\n\nexport default lokiGrammar;\n","import { CoreApp, DashboardLoadedEvent, DataQueryRequest, DataQueryResponse } from '@grafana/data';\nimport { reportInteraction, config } from '@grafana/runtime';\nimport { variableRegex } from 'app/features/variables/utils';\n\nimport { QueryEditorMode } from '../prometheus/querybuilder/shared/types';\n\nimport {\n  REF_ID_STARTER_ANNOTATION,\n  REF_ID_DATA_SAMPLES,\n  REF_ID_STARTER_LOG_ROW_CONTEXT,\n  REF_ID_STARTER_LOG_VOLUME,\n} from './datasource';\nimport pluginJson from './plugin.json';\nimport { getNormalizedLokiQuery, isLogsQuery, obfuscate, parseToNodeNamesArray } from './queryUtils';\nimport { LokiQuery, LokiQueryType } from './types';\n\ntype LokiOnDashboardLoadedTrackingEvent = {\n  grafana_version?: string;\n  dashboard_id?: string;\n  org_id?: number;\n\n  /* The number of Loki queries present in the dashboard*/\n  queries_count: number;\n\n  /* The number of Loki logs queries present in the dashboard*/\n  logs_queries_count: number;\n\n  /* The number of Loki metric queries present in the dashboard*/\n  metric_queries_count: number;\n\n  /* The number of Loki instant queries present in the dashboard*/\n  instant_queries_count: number;\n\n  /* The number of Loki range queries present in the dashboard*/\n  range_queries_count: number;\n\n  /* The number of Loki queries created in builder mode present in the dashboard*/\n  builder_mode_queries_count: number;\n\n  /* The number of Loki queries created in code mode present in the dashboard*/\n  code_mode_queries_count: number;\n\n  /* The number of Loki queries with used template variables present in the dashboard*/\n  queries_with_template_variables_count: number;\n\n  /* The number of Loki queries with changed resolution present in the dashboard*/\n  queries_with_changed_resolution_count: number;\n\n  /* The number of Loki queries with changed line limit present in the dashboard*/\n  queries_with_changed_line_limit_count: number;\n\n  /* The number of Loki queries with changed legend present in the dashboard*/\n  queries_with_changed_legend_count: number;\n};\n\nexport const onDashboardLoadedHandler = ({\n  payload: { dashboardId, orgId, grafanaVersion, queries },\n}: DashboardLoadedEvent<LokiQuery>) => {\n  try {\n    // We only want to track visible Loki queries\n    const lokiQueries = queries[pluginJson.id]\n      .filter((query) => !query.hide)\n      .map((query) => getNormalizedLokiQuery(query));\n\n    if (!lokiQueries?.length) {\n      return;\n    }\n\n    const logsQueries = lokiQueries.filter((query) => isLogsQuery(query.expr));\n    const metricQueries = lokiQueries.filter((query) => !isLogsQuery(query.expr));\n    const instantQueries = lokiQueries.filter((query) => query.queryType === LokiQueryType.Instant);\n    const rangeQueries = lokiQueries.filter((query) => query.queryType === LokiQueryType.Range);\n    const builderModeQueries = lokiQueries.filter((query) => query.editorMode === QueryEditorMode.Builder);\n    const codeModeQueries = lokiQueries.filter((query) => query.editorMode === QueryEditorMode.Code);\n    const queriesWithTemplateVariables = lokiQueries.filter(isQueryWithTemplateVariables);\n    const queriesWithChangedResolution = lokiQueries.filter(isQueryWithChangedResolution);\n    const queriesWithChangedLineLimit = lokiQueries.filter(isQueryWithChangedLineLimit);\n    const queriesWithChangedLegend = lokiQueries.filter(isQueryWithChangedLegend);\n\n    const event: LokiOnDashboardLoadedTrackingEvent = {\n      grafana_version: grafanaVersion,\n      dashboard_id: dashboardId,\n      org_id: orgId,\n      queries_count: lokiQueries.length,\n      logs_queries_count: logsQueries.length,\n      metric_queries_count: metricQueries.length,\n      instant_queries_count: instantQueries.length,\n      range_queries_count: rangeQueries.length,\n      builder_mode_queries_count: builderModeQueries.length,\n      code_mode_queries_count: codeModeQueries.length,\n      queries_with_template_variables_count: queriesWithTemplateVariables.length,\n      queries_with_changed_resolution_count: queriesWithChangedResolution.length,\n      queries_with_changed_line_limit_count: queriesWithChangedLineLimit.length,\n      queries_with_changed_legend_count: queriesWithChangedLegend.length,\n    };\n\n    reportInteraction('grafana_loki_dashboard_loaded', event);\n  } catch (error) {\n    console.error('error in loki tracking handler', error);\n  }\n};\n\nconst isQueryWithTemplateVariables = (query: LokiQuery): boolean => {\n  return variableRegex.test(query.expr);\n};\n\nconst isQueryWithChangedResolution = (query: LokiQuery): boolean => {\n  if (!query.resolution) {\n    return false;\n  }\n  // 1 is the default resolution\n  return query.resolution !== 1;\n};\n\nconst isQueryWithChangedLineLimit = (query: LokiQuery): boolean => {\n  return query.maxLines !== null && query.maxLines !== undefined;\n};\n\nconst isQueryWithChangedLegend = (query: LokiQuery): boolean => {\n  if (!query.legendFormat) {\n    return false;\n  }\n  return query.legendFormat !== '';\n};\n\nconst shouldNotReportBasedOnRefId = (refId: string): boolean => {\n  const starters = [REF_ID_STARTER_ANNOTATION, REF_ID_STARTER_LOG_ROW_CONTEXT, REF_ID_STARTER_LOG_VOLUME];\n\n  if (refId === REF_ID_DATA_SAMPLES || starters.some((starter) => refId.startsWith(starter))) {\n    return true;\n  }\n  return false;\n};\n\nexport function trackQuery(\n  response: DataQueryResponse,\n  request: DataQueryRequest<LokiQuery> & { targets: LokiQuery[] },\n  startTime: Date\n): void {\n  // We only want to track usage for these specific apps\n  const { app, targets: queries } = request;\n\n  if (app === CoreApp.Dashboard || app === CoreApp.PanelViewer) {\n    return;\n  }\n\n  let totalBytes = 0;\n  for (const frame of response.data) {\n    const byteKey = frame.meta?.custom?.lokiQueryStatKey;\n    if (byteKey) {\n      totalBytes +=\n        frame.meta?.stats?.find((stat: { displayName: string }) => stat.displayName === byteKey)?.value ?? 0;\n    }\n  }\n\n  for (const query of queries) {\n    if (shouldNotReportBasedOnRefId(query.refId)) {\n      return;\n    }\n\n    reportInteraction('grafana_loki_query_executed', {\n      app,\n      grafana_version: config.buildInfo.version,\n      editor_mode: query.editorMode,\n      has_data: response.data.some((frame) => frame.length > 0),\n      has_error: response.error !== undefined,\n      legend: query.legendFormat,\n      line_limit: query.maxLines,\n      parsed_query: parseToNodeNamesArray(query.expr).join(','),\n      obfuscated_query: obfuscate(query.expr),\n      query_type: isLogsQuery(query.expr) ? 'logs' : 'metric',\n      query_vector_type: query.queryType,\n      resolution: query.resolution,\n      simultaneously_sent_query_count: queries.length,\n      time_range_from: request?.range?.from?.toISOString(),\n      time_range_to: request?.range?.to?.toISOString(),\n      time_taken: Date.now() - startTime.getTime(),\n      bytes_processed: totalBytes,\n    });\n  }\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\n\nimport { QueryEditorMode } from '../prometheus/querybuilder/shared/types';\n\nexport interface LokiInstantQueryRequest {\n  query: string;\n  limit?: number;\n  time?: string;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport interface LokiRangeQueryRequest {\n  query: string;\n  limit?: number;\n  start?: number;\n  end?: number;\n  step?: number;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport enum LokiResultType {\n  Stream = 'streams',\n  Vector = 'vector',\n  Matrix = 'matrix',\n}\n\nexport enum LokiQueryType {\n  Range = 'range',\n  Instant = 'instant',\n  Stream = 'stream',\n}\n\nexport enum LokiQueryDirection {\n  Backward = 'backward',\n  Forward = 'forward',\n}\n\nexport interface LokiQuery extends DataQuery {\n  queryType?: LokiQueryType;\n  expr: string;\n  direction?: LokiQueryDirection;\n  legendFormat?: string;\n  maxLines?: number;\n  resolution?: number;\n  /** Used only to identify supporting queries, e.g. logs volume, logs sample and data sample */\n  supportingQueryType?: SupportingQueryType;\n  /* @deprecated now use queryType */\n  range?: boolean;\n  /* @deprecated now use queryType */\n  instant?: boolean;\n  editorMode?: QueryEditorMode;\n}\n\nexport interface LokiOptions extends DataSourceJsonData {\n  maxLines?: string;\n  derivedFields?: DerivedFieldConfig[];\n  alertmanager?: string;\n  keepCookies?: string[];\n}\n\nexport interface LokiStats {\n  [component: string]: {\n    [label: string]: number;\n  };\n}\n\nexport interface LokiVectorResult {\n  metric: { [label: string]: string };\n  value: [number, string];\n}\n\nexport interface LokiVectorResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Vector;\n    result: LokiVectorResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiMatrixResult {\n  metric: Record<string, string>;\n  values: Array<[number, string]>;\n}\n\nexport interface LokiMatrixResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Matrix;\n    result: LokiMatrixResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiStreamResult {\n  stream: Record<string, string>;\n  values: Array<[string, string]>;\n}\n\nexport interface LokiStreamResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Stream;\n    result: LokiStreamResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiTailResponse {\n  streams: LokiStreamResult[];\n  dropped_entries?: Array<{\n    labels: Record<string, string>;\n    timestamp: string;\n  }> | null;\n}\n\nexport type LokiResult = LokiVectorResult | LokiMatrixResult | LokiStreamResult;\nexport type LokiResponse = LokiVectorResponse | LokiMatrixResponse | LokiStreamResponse;\n\nexport interface LokiLogsStreamEntry {\n  line: string;\n  ts: string;\n}\n\nexport interface LokiExpression {\n  regexp: string;\n  query: string;\n}\n\nexport type DerivedFieldConfig = {\n  matcherRegex: string;\n  name: string;\n  url?: string;\n  urlDisplayLabel?: string;\n  datasourceUid?: string;\n};\n\nexport interface TransformerOptions {\n  legendFormat?: string;\n  query: string;\n  refId: string;\n  scopedVars: ScopedVars;\n  meta?: QueryResultMeta;\n}\n\nexport enum LokiVariableQueryType {\n  LabelNames,\n  LabelValues,\n}\n\nexport interface LokiVariableQuery extends DataQuery {\n  type: LokiVariableQueryType;\n  label?: string;\n  stream?: string;\n}\n\nexport interface QueryStats {\n  streams: number;\n  chunks: number;\n  bytes: number;\n  entries: number;\n}\n\nexport enum SupportingQueryType {\n  LogsVolume = 'logsVolume',\n  LogsSample = 'logsSample',\n  DataSample = 'dataSample',\n}\n\nexport interface ContextFilter {\n  enabled: boolean;\n  label: string;\n  value: string;\n  fromParser: boolean;\n  description?: string;\n}\n","/**\n * Shared types that can be reused by Loki and other data sources\n */\n\nimport { ComponentType } from 'react';\n\nimport { DataSourceApi, RegistryItem, SelectableValue } from '@grafana/data';\n\nexport interface QueryBuilderLabelFilter {\n  label: string;\n  op: string;\n  value: string;\n}\n\nexport interface QueryBuilderOperation {\n  id: string;\n  params: QueryBuilderOperationParamValue[];\n}\n\nexport interface QueryWithOperations {\n  operations: QueryBuilderOperation[];\n}\n\nexport interface QueryBuilderOperationDef<T = any> extends RegistryItem {\n  documentation?: string;\n  params: QueryBuilderOperationParamDef[];\n  defaultParams: QueryBuilderOperationParamValue[];\n  category: string;\n  hideFromList?: boolean;\n  alternativesKey?: string;\n  /** Can be used to control operation placement when adding a new operations, lower are placed first */\n  orderRank?: number;\n  renderer: QueryBuilderOperationRenderer;\n  addOperationHandler: QueryBuilderAddOperationHandler<T>;\n  paramChangedHandler?: QueryBuilderOnParamChangedHandler;\n  explainHandler?: QueryBuilderExplainOperationHandler;\n  changeTypeHandler?: (op: QueryBuilderOperation, newDef: QueryBuilderOperationDef<T>) => QueryBuilderOperation;\n}\n\nexport type QueryBuilderAddOperationHandler<T> = (\n  def: QueryBuilderOperationDef,\n  query: T,\n  modeller: VisualQueryModeller\n) => T;\n\nexport type QueryBuilderExplainOperationHandler = (op: QueryBuilderOperation, def?: QueryBuilderOperationDef) => string;\n\nexport type QueryBuilderOnParamChangedHandler = (\n  index: number,\n  operation: QueryBuilderOperation,\n  operationDef: QueryBuilderOperationDef\n) => QueryBuilderOperation;\n\nexport type QueryBuilderOperationRenderer = (\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string\n) => string;\n\nexport type QueryBuilderOperationParamValue = string | number | boolean;\n\nexport interface QueryBuilderOperationParamDef {\n  name: string;\n  type: 'string' | 'number' | 'boolean';\n  options?: string[] | number[] | Array<SelectableValue<string>>;\n  hideName?: boolean;\n  restParam?: boolean;\n  optional?: boolean;\n  placeholder?: string;\n  description?: string;\n  minWidth?: number;\n  editor?: ComponentType<QueryBuilderOperationParamEditorProps>;\n  runQueryOnEnter?: boolean;\n}\n\nexport interface QueryBuilderOperationEditorProps {\n  operation: QueryBuilderOperation;\n  index: number;\n  query: any;\n  datasource: DataSourceApi;\n  queryModeller: VisualQueryModeller;\n  onChange: (index: number, update: QueryBuilderOperation) => void;\n  onRemove: (index: number) => void;\n}\n\nexport interface QueryBuilderOperationParamEditorProps {\n  value?: QueryBuilderOperationParamValue;\n  paramDef: QueryBuilderOperationParamDef;\n  /** Parameter index */\n  index: number;\n  operation: QueryBuilderOperation;\n  operationIndex: number;\n  query: any;\n  datasource: DataSourceApi;\n  onChange: (index: number, value: QueryBuilderOperationParamValue) => void;\n  onRunQuery: () => void;\n}\n\nexport enum QueryEditorMode {\n  Code = 'code',\n  Builder = 'builder',\n}\n\nexport interface VisualQueryModeller {\n  getOperationsForCategory(category: string): QueryBuilderOperationDef[];\n  getAlternativeOperations(key: string): QueryBuilderOperationDef[];\n  getCategories(): string[];\n  getOperationDef(id: string): QueryBuilderOperationDef | undefined;\n}\n","import { LRParser } from '@lezer/lr';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Json$1 = 1,\n  Logfmt$1 = 2,\n  Unpack$1 = 3,\n  Pattern$1 = 4,\n  Regexp$1 = 5,\n  Unwrap$1 = 6,\n  Ip$1 = 7,\n  LabelFormat$1 = 8,\n  LineFormat$1 = 9,\n  LabelReplace$1 = 10,\n  Offset$1 = 11,\n  Bool$1 = 12,\n  On$1 = 13,\n  Ignoring$1 = 14,\n  GroupLeft$1 = 15,\n  GroupRight$1 = 16,\n  By$1 = 17,\n  Without$1 = 18,\n  And$1 = 19,\n  Or$1 = 20,\n  Unless$1 = 21,\n  Sum$1 = 22,\n  Avg$1 = 23,\n  Count$1 = 24,\n  Max$1 = 25,\n  Min$1 = 26,\n  Stddev$1 = 27,\n  Stdvar$1 = 28,\n  Bottomk$1 = 29,\n  Topk$1 = 30;\n\nconst keywordTokens = {\n    json: Json$1,\n    logfmt : Logfmt$1,\n    unpack: Unpack$1,\n    pattern : Pattern$1,\n    regexp : Regexp$1,\n    ip : Ip$1,\n    label_format : LabelFormat$1,\n    line_format : LineFormat$1,\n    label_replace: LabelReplace$1,\n    offset: Offset$1,\n    bool: Bool$1,\n    on: On$1,\n    ignoring: Ignoring$1,\n    group_left: GroupLeft$1,\n    group_right: GroupRight$1,\n    unwrap: Unwrap$1,\n};\n\nconst specializeIdentifier = (value, stack) => {\n    return keywordTokens[value.toLowerCase()] || -1;\n};\n\n\nconst contextualKeywordTokens = {\n    by: By$1,\n    without: Without$1,\n    and: And$1,\n    or: Or$1,\n    unless: Unless$1,\n    sum: Sum$1,\n    avg: Avg$1,\n    count: Count$1,\n    max: Max$1,\n    min: Min$1,\n    stddev: Stddev$1,\n    stdvar: Stdvar$1,\n    bottomk: Bottomk$1,\n    topk: Topk$1\n};\n\nconst extendIdentifier = (value, stack) => {\n    return contextualKeywordTokens[value.toLowerCase()] || -1;\n};\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_Identifier = {__proto__:null,count_over_time:257, rate:259, rate_counter:261, bytes_over_time:263, bytes_rate:265, avg_over_time:267, sum_over_time:269, min_over_time:271, max_over_time:273, stddev_over_time:275, stdvar_over_time:277, quantile_over_time:279, first_over_time:281, last_over_time:283, absent_over_time:285, bytes:291, duration:293, duration_seconds:295};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"AYOYQPOOO#YQPO'#DPO$iQPO'#DOOYQPO'#DOOOQO'#D{'#D{O$vQPO'#DzOOQO'#Eh'#EhO${QPO'#EgQ%WQPOOOOQO'#Ev'#EvO&XQPO'#EvO&^QPO'#EwOOQO'#Dy'#DyOOQO'#C}'#C}OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[O&cQPO'#DROOQO'#DQ'#DQO&qQPO,59kOOQO'#D^'#D^O&yQPO'#D]OOQO'#D['#D[O'RQPO'#DZO(lQPO'#DZOOQO'#DY'#DYO*eQPO,59jO+sQPO,59jO+zQPO,5:eO,RQPO,5:fO,^QPO'#EeO.`QPO,5;RO.gQPO,5;RO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TOOQO,5;b,5;bOYQPO,5;cO0uQPO,59mO0zQPO1G/VOOQO1G/V1G/VOOQO'#Da'#DaOOQO,59w,59wO1SQPO,59wOOQO,59v,59vO1XQPO'#DRO1vQPO'#DcOOQO'#Dc'#DcO3dQPO'#DcOOQO'#Di'#DiOOQO'#Dg'#DgO)RQPO'#DgO3iQPO,59uO5SQPO'#DuO5XQPO'#DvOOQO,59u,59uOOQO,59t,59tOOQO1G/U1G/UOOQO1G0P1G0PO5^QPO'#E]O,UQPO'#E]O5rQPO1G0QO5wQPO1G0QO5|QPO,5;PO6UQPO1G0mO7aQPO1G0mO7hQPO1G0mO7oQPO'#EkO9tQPO'#EjO:OQPO'#EjOYQPO1G0oOYQPO1G0oOYQPO1G0oOYQPO1G0oOYQPO1G0oOYQPO1G0oO:YQPO1G0}OOQO1G/X1G/XOOQO1G/W1G/WOOQO7+$q7+$qO:aQPO1G/cO:fQPO,59mO:lQPO,5:UO:wQPO'#DfOOQO'#De'#DeO:|QPO,5:OOOQO,59},59}O<gQPO,5:RO)RQPO,5:RO)RQPO,5:ROOQO,5:a,5:aO<uQPO'#DxOOQO'#Dw'#DwO<zQPO,5:bO>eQPO'#DZO5^QPO,5:wO>lQPO'#E^O>qQPO,5:wO?[QPO,5:wO?fQPO,5:wO?mQPO,5:wO?rQPO7+%lO,UQPO7+%lOOQO'#Ef'#EfOASQPO1G0kOOQO1G0k1G0kOA[QPO7+&XOYQPO7+&XOBlQPO7+&XOBsQPO7+&XOBzQQO'#ElOOQO,5;V,5;VOEPQPO,5;UOEWQPO,5;UOFiQPO7+&ZOFpQPO7+&ZOOQO7+&Z7+&ZOF}QPO7+&ZOGUQPO7+&ZOHZQPO7+&ZOHkQPO7+&iOHpQPO7+$}OHuQPO1G/nOOQO1G/p1G/pOOQO1G/w1G/wOOQO1G/y1G/yOHzQPO,5:QOIPQPO,5:POOQO1G/m1G/mOIUQPO1G/mOJoQPO,5:dO5XQPO,5:cOJwQPO,5:zO>qQPO1G0cOKVQPO1G0cOK_QPO,5:xO)RQPO,5:zOKdQPO1G0cOKkQPO'#E_OKpQPO1G0cOKdQPO1G0cOKxQPO1G0cOLPQPO1G0cO5mQPO1G0cOOQO1G0c1G0cOOQO<<IW<<IWOL[QPO<<IWOLaQPO,5;QOOQO7+&V7+&VOOQO<<Is<<IsOLfQPO<<IsOYQPO<<IsOOQO'#En'#EnOLmQPO,5;WOOQO'#Em'#EmOOQO,5;W,5;WOOQO1G0p1G0pOLuQPO1G0pONuQPO<<JTOOQO<<Hi<<HiONzQPO7+%YOOQO1G/l1G/lOOQO1G/k1G/kOOQO1G0O1G0OOOQO1G/}1G/}OOQO'#Ea'#EaOOQO1G0f1G0fO! PQPO1G0fOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO7+%}7+%}OOQO1G0d1G0dO! UQPO1G0fO! jQPO7+%}OOQO,5:y,5:yO! rQPO7+%}O5mQPO7+%}O! yQPO7+%}O!!UQPOAN>rOOQO1G0l1G0lO!#fQPOAN?_O!$vQPOAN?_O!$}QQO1G0rOOQO1G0r1G0rOOQO7+&[7+&[O!%VQPOAN?oO!%[QPO<<HtO!%aQPO7+&QO!%fQPO<<IiO!%nQPO<<IiO!%vQPO<<IiO!&OQPO'#E`OOQO<<Ii<<IiOOQOG24^G24^OOQOG24yG24yOOQO1G0s1G0sOOQO7+&^7+&^O!&TQPOG25ZOOQOAN>`AN>`O!&YQPO<<IlOOQOAN?TAN?TO!&_QPOAN?TO!&gQPOLD*uOOQOAN?WAN?WOOQO,5:b,5:bO!&lQPO!$'NaO!&qQPO!)9C{O!&vQPO!.K9gOOQO!4//R!4//RO5XQPO'#DvO!&{QPO'#DZO!'jQPO,59jO!'tQPO'#DOOYQPO1G0oOYQPO1G0oOYQPO1G0oOYQPO1G0oOYQPO1G0oOYQPO1G0oO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO.lQPO,5;TO!)PQPO7+&ZO!)WQPO7+&ZO!)eQPO7+&ZO!*mQPO7+&ZO!*tQPO7+&ZO!)lQPO'#Ei\",\n  stateData: \"!+R~O#nOSoOS~OYZOfUOgUOhUOiUOjUOkUOlUOmUOnUO!hXO#dYO#eYO#oPO#rRO#t^O#u_O#v`O#waO#xbO#ycO#zdO#{eO#|fO#}gO$OhO$PiO$QjO$RkO$SlO~OvmO~OypO{pO!RpO!SpOcrXdrXerX!_rX!arX!brX!crX!drX#drX#erX#frX#grX#hrX#irX~O!UtO#lrX#srX~P#_O#ryO~OazObzO#r{O~Oc!OOd}Oe!OOy!SO!_!SO!a!SO!b!SO!c!SO!d!SO#d!PO#e!PO#f!QO#g!QO#h!QO#i!RO~O!h!TO~O#r!UO~Ow!VOy!VOz!VO{!VO~O#p!WO#q!XO~OV!YOx!ZO~OypO{pO!RpO!SpOc}Xd}Xe}X!U}X!_}X!a}X!b}X!c}X!d}X#d}X#e}X#f}X#g}X#h}X#i}X#l}X#s}X$T}X#p}X~OP!_OQ!`OR!`OS!aOT!aOW!gOX!fOv!^O#r!dO~OypO{pO!RpO!SpOcradraera!_ra!ara!bra!cra!dra#dra#era#fra#gra#hra#ira~O!UtO#lra#sra~P)ZOcqXdqXeqXyqX!_qX!aqX!bqX!cqX!dqX#dqX#eqX#fqX#gqX#hqX#iqX~O#s!jO~P*rO#s!kO~P*rO!h!oO#oPO#r!mO~O#r!pO~OYZOfUOgUOhUOiUOjUOkUOlUOmUOnUO#dYO#eYO#oPO#rRO#t^O#u_O#v`O#waO#xbO#ycO#zdO#{eO#|fO#}gO$OhO$PiO$QjO$RkO$SlO~O!h!rO~P,cO#r!sO~O[!vO]!tO^!tOY#^Pf#^Pg#^Ph#^Pi#^Pj#^Pk#^Pl#^Pm#^Pn#^P!h#^P#d#^P#e#^P#o#^P#r#^P#t#^P#u#^P#v#^P#w#^P#x#^P#y#^P#z#^P#{#^P#|#^P#}#^P$O#^P$P#^P$Q#^P$R#^P$S#^P~Ox#OO~OvmO#q#QO~O#r#RO~Ow#SOy#SOz!VO{!VO!_#TO!a#TO!b#TO!c#TO!d#TO~Ov#UOc!VXd!VXe!VXy!VX{!VX!R!VX!S!VX!U!VX!_!VX!a!VX!b!VX!c!VX!d!VX#d!VX#e!VX#f!VX#g!VX#h!VX#i!VX#l!VX#s!VX$T!VX#p!VX~Ox#XO~Oc#ZOd#[O#p#ZOe}ay}a{}a!R}a!S}a!U}a!_}a!a}a!b}a!c}a!d}a#d}a#e}a#f}a#g}a#h}a#i}a#l}a#s}a$T}a~Ox#]O~Ov#^O~OypO{pO!RpO!SpO!U#aO$T#cO~O#s#hO~O#p#iO~Ov#jO#s#lO~O#s#mO~P*rOc#jXd#jXe#jXy#jX!_#jX!a#jX!b#jX!c#jX!d#jX#d#jX#e#jX#f#jX#g#jX#h#jX#i#jX#s#jX~O#p#nO~P6]O!h#pO~P,cO#r#qO~OY#^Xf#^Xg#^Xh#^Xi#^Xj#^Xk#^Xl#^Xm#^Xn#^X!h#^X#d#^X#e#^X#o#^X#r#^X#t#^X#u#^X#v#^X#w#^X#x#^X#y#^X#z#^X#{#^X#|#^X#}#^X$O#^X$P#^X$Q#^X$R#^X$S#^X~O_#sO`#sO~P7tO]!tO^!tO~P7tO#p#{O~P*rOx#|O~OV#}Ox#OO!`$OO!f$PO!h$QO~Ow$RO~O#p$SOc!Wad!Wae!Way!Wa{!Wa!R!Wa!S!Wa!U!Wa!_!Wa!a!Wa!b!Wa!c!Wa!d!Wa#d!Wa#e!Wa#f!Wa#g!Wa#h!Wa#i!Wa#l!Wa#s!Wa$T!Wa~Oc#ZOd#[O#p#ZO#s$TO~Ow$VO~O#p$WOc!jad!jae!jay!ja{!ja!R!ja!S!ja!U!ja!_!ja!a!ja!b!ja!c!ja!d!ja#d!ja#e!ja#f!ja#g!ja#h!ja#i!ja#l!ja#s!ja$T!ja~OU$XO~P(lO!`$[O~O!U$]O$T#cO~OypO{pO!RpO!SpO!U#aO~OZ$_O#s#Pa~P>yO#s$dO~P5^O#s$eO~OazObzOc!nqd!nqe!nqy!nq!_!nq!a!nq!b!nq!c!nq!d!nq#d!nq#e!nq#f!nq#g!nq#h!nq#i!nq#l!nq#s!nq#p!nq~O#p$hO#s$iO~OazObzOc#Zqd#Zqe#Zqy#Zq!_#Zq!a#Zq!b#Zq!c#Zq!d#Zq#d#Zq#e#Zq#f#Zq#g#Zq#h#Zq#i#Zq#l#Zq#s#Zq#p#Zq~O#s$jO~P*rO#p$lO~P6]O#c$mO#s$pO~OY#^af#^ag#^ah#^ai#^aj#^ak#^al#^am#^an#^a!h#^a#d#^a#e#^a#o#^a#t#^a#u#^a#v#^a#w#^a#x#^a#y#^a#z#^a#{#^a#|#^a#}#^a$O#^a$P#^a$Q#^a$R#^a$S#^a~O#r#qO~PCSO_$rO`$rO#r#^a~PCSOc!OOe!OOy!SO!_!SO!a!SO!b!SO!c!SO!d!SO#d!PO#e!PO#f#]q#g#]q#h#]q#i#]q#l#]q#s#]q~Od#]q~PEeOc#]qd#]qe#]q~PEkOd}O~PEeO#l#]q#s#]q~P%WOc#]qd#]qe#]qy#]q!_#]q!a#]q!b#]q!c#]q!d#]q#f#]q#g#]q#h#]q#i#]q~O#d!PO#e!PO#l#]q#s#]q~PG`Ox$sO~O#s$tO~O#r$uO~Ox$vO~Ov#UO~Oc#ZO#p#ZOd!Zie!Ziy!Zi{!Zi!R!Zi!S!Zi!U!Zi!_!Zi!a!Zi!b!Zi!c!Zi!d!Zi#d!Zi#e!Zi#f!Zi#g!Zi#h!Zi#i!Zi#l!Zi#s!Zi$T!Zi~Ov$xOx$xO~Ov${O$V$}O$W%OO$X%PO~OZ$_O#s#Pi~O$U%RO~O#s#Pi~P>yO!`%UO~O!U$]O#s#Pi~O#s%WO~P5^O!U$]O#s%WO$T#cO~O#s%YO~Ov%ZO~O#s%[O~P*rO#p%^O#s%_O~O#r#qOY#^if#^ig#^ih#^ii#^ij#^ik#^il#^im#^in#^i!h#^i#d#^i#e#^i#o#^i#t#^i#u#^i#v#^i#w#^i#x#^i#y#^i#z#^i#{#^i#|#^i#}#^i$O#^i$P#^i$Q#^i$R#^i$S#^i~O#p%aO~Ox%bO~O#r%cO~Oc#ZOd#[O#p#ZO!U#Si$T#Si#s#Si~O!U$]O#s#Pq~O#s#Pq~P>yOZ%fO!U%gO#s#Pq~OazObzOc!n!Rd!n!Re!n!Ry!n!R!_!n!R!a!n!R!b!n!R!c!n!R!d!n!R#d!n!R#e!n!R#f!n!R#g!n!R#h!n!R#i!n!R#l!n!R#s!n!R#p!n!R~OazObzOc#Z!Rd#Z!Re#Z!Ry#Z!R!_#Z!R!a#Z!R!b#Z!R!c#Z!R!d#Z!R#d#Z!R#e#Z!R#f#Z!R#g#Z!R#h#Z!R#i#Z!R#l#Z!R#s#Z!R#p#Z!R~O#s%jO~P*rO#c$mO#s%lO~Ox%mO~O#s%nO~Ov%oO~O!U$]O#s#Py~OZ$_O#s#Py~O!U%gO!`%UO~OU$XO~O#p%rO~O#s%sO~O!U$]O#s#P!R~Ox%uO~O#p%vO~Ox%wO~O#s%xO~OP!_OQ!`OR!`OS!aOT!aOW%yOX!fOv!^O#r!dO~O!U%zO#pra~P)ZO!U%zO#prX~P#_Oc&UOe&UOy&YO!_&YO!a&YO!b&YO!c&YO!d&YO#d&VO#e&VO#f#]q#g#]q#h#]q#i#]q#p#]q~Od#]q~P!(OOc#]qd#]qe#]q~P!(UOd&TO~P!(OOc&UOd&TOe&UOy&YO!_&YO!a&YO!b&YO!c&YO!d&YO#d&VO#e&VO#f&WO#g&WO#h&WO#i&XO~O#p#]q~P!)lO#d&VO#e&VO#p#]q~PG`O\",\n  goto: \"/^#lPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#m$l%T%s%vPPPPPP&V&i&y'X'jPP'yP'|'|(R(U([(m(m(vPPPPPP(vP(mP'|'|)P)V)^*P*f*{*{*{*{*{*{*{*{*{*{*{*{*{*{*{+b+k,O,[,t,w,w,w,z-Z*P-^*P-s.i.z/T/WPPPPPPP*P*P[WOR{!s#n$lQ#u!wQ#v!xS#w!y&PQ#x!zQ#y!{Q#z!|Q&Z%}Q&[&OQ&]&QQ&^&RQ&_&SR&`!Ut]O{!U!s!w!x!y!z!{!|#n$l%}&O&P&Q&R&SRwRjQOR{!U!s!w!x!y!z!{!|#n$lS!ly#iQ#f!m]%|%}&O&P&Q&R&SRoPQnP^!ct!d#Z#[#a$]%zR#P!WQvQQ#b!lQ$^#eQ$b#fQ%V$aR%{%|[uQ!l#e#f$a%|]!iv#b$^$b%V%{isQv!l#b#e#f$^$a$b%V%{%|hrQv!l#b#e#f$^$a$b%V%{%|R!]skqQsv!l#b#e#f$^$a$b%V%{%|R![qV!ht#a%zR#W!_Q#V!_R$w$SU!et#a%zQ#Y!dQ$T#ZQ$U#[R%S$]_!ct!d#Z#[#a$]%z_!bt!d#Z#[#a$]%zQ#`!gR%t%yS#_!g%yR$y$Wj]O!w!x!y!z!{!|%}&O&P&Q&R&SQxRQ!q{Q!}!UQ#o!sQ$k#nR%]$lw[OR{!U!s!w!x!y!z!{!|#n$l%}&O&P&Q&R&SwTOR{!U!s!w!x!y!z!{!|#n$l%}&O&P&Q&R&SwSOR{!U!s!w!x!y!z!{!|#n$l%}&O&P&Q&R&SQ!nyQ#g!mR$g#iS#e!l#fW$Z#b#d$b$cQ%Q$YQ%X$dR%e%WQ$a#eQ%Q$ZQ%h%XR%p%eQ#d!lS$Y#b$bQ$`#eQ$c#fS%T$^$aS%d%V%XR%q%fR$|$XR$z$XQ|VQ$f#hQ$j#mQ%i%YR%j%[R#k!pwVOR{!U!s!w!x!y!z!{!|#n$l%}&O&P&Q&R&SQ!w}Q!x!OQ!y!PQ!z!QQ!{!RQ!|!SQ%}&TQ&O&UQ&P&VQ&Q&WQ&R&XR&S&Yh!u}!O!P!Q!R!S&T&U&V&W&X&YR#t!vQ#r!tQ$q#sR%`$rR$n#qQ$o#qR%k%^\",\n  nodeNames: \" Json Logfmt Unpack Pattern Regexp Unwrap Ip LabelFormat LineFormat LabelReplace Offset Bool On Ignoring GroupLeft GroupRight By Without And Or Unless Sum Avg Count Max Min Stddev Stdvar Bottomk Topk LineComment LogQL Expr LogExpr Selector Matchers Matcher Identifier Eq String Neq Re Nre PipelineExpr PipelineStage LineFilters LineFilter Filter PipeExact PipeMatch FilterOp Pipe LabelParser JsonExpressionParser JsonExpressionList JsonExpression LabelFilter IpLabelFilter UnitFilter DurationFilter Gtr Duration Gte Lss Lte Eql BytesFilter Bytes NumberFilter Number LineFormatExpr LabelFormatExpr LabelsFormat LabelFormatMatcher MetricExpr RangeAggregationExpr RangeOp CountOverTime Rate RateCounter BytesOverTime BytesRate AvgOverTime SumOverTime MinOverTime MaxOverTime StddevOverTime StdvarOverTime QuantileOverTime FirstOverTime LastOverTime AbsentOverTime LogRangeExpr Range OffsetExpr UnwrapExpr ConvOp BytesConv DurationConv DurationSecondsConv Grouping Labels VectorAggregationExpr VectorOp BinOpExpr BinOpModifier OnOrIgnoringModifier GroupingLabels GroupingLabelList GroupingLabel LabelName Add Sub Mul Div Mod Pow LiteralExpr LabelReplaceExpr\",\n  maxTerm: 147,\n  skippedNodes: [0,31],\n  repeatNodeCount: 0,\n  tokenData: \"3X~RvX^#ipq#iqr$^rs$qst%cuv%nxy%syz%xz{%}{|&S|}&X}!O&^!O!P&c!P!Q'c!Q!R'h!R![)O![!]0O!^!_0d!_!`0q!`!a1W!c!}1e!}#O1{#P#Q2Q#Q#R2V#R#S1e#S#T2[#T#o1e#o#p2h#p#q2m#q#r3S#y#z#i$f$g#i#BY#BZ#i$IS$I_#i$I|$JO#i$JT$JU#i$KV$KW#i&FU&FV#i~#nY#n~X^#ipq#i#y#z#i$f$g#i#BY#BZ#i$IS$I_#i$I|$JO#i$JT$JU#i$KV$KW#i&FU&FV#i~$aQ!_!`$g#r#s$l~$lOy~~$qO{~~$tUOY$qZr$qrs%Ws#O$q#O#P%]#P~$q~%]Ox~~%`PO~$q~%hQo~OY%cZ~%c~%sO#h~~%xO#r~~%}O#s~~&SO#f~~&XO#d~~&^O#p~~&cO#e~~&fP!Q![&i~&nR!h~!Q![&i!g!h&w#X#Y&w~&zR{|'T}!O'T!Q!['Z~'WP!Q!['Z~'`P!h~!Q!['Z~'hO#g~~'me!h~!O!P&i!Q![)O!g!h*c!i!j+Q!m!n+Q!o!p+Q!r!s+Q!v!w+Q#U#V*u#W#X+Z#X#Y-]#Z#[-o#[#]+r#_#`-o#a#b-x#d#e-o#g#h,z#h#i-o#k#l.Z#l#m/d#m#n.u~)Td!h~!O!P&i!Q![)O!g!h*c!i!j+Q!m!n+Q!o!p+Q!r!s+Q!v!w+Q#U#V*u#W#X+Z#X#Y-]#Z#[-o#[#]+r#_#`-o#a#b-x#d#e-o#g#h,z#h#i-o#k#l.Z#m#n.u~*fT{|'T}!O'T!Q!['Z!d!e*u#]#^*z~*zO!f~~*}P#U#V*u~+TQ!d!e*u#]#^*z~+`P!`~!Q![+c~+fS!Q![+c#[#]+r#a#b,W#g#h,z~+wP!`~!Q![+z~+}R!Q![+z#a#b,W#g#h,z~,]Q!`~!Q![,c#g#h,u~,fR!Q![,c#a#b,o#g#h,z~,rP#g#h,u~,zO!`~~-PP!`~!Q![-S~-VQ!Q![-S#a#b,o~-`T{|'T}!O'T!Q!['Z#U#V*u#]#^*z~-rQ#U#V*u#]#^*z~-}S!`~!Q![,c#U#V*u#]#^*z#g#h,u~.`P!`~!Q![.c~.fT!Q![.c#W#X+Z#[#]+r#a#b,W#g#h,z~.zP!`~!Q![.}~/QU!Q![.}#W#X+Z#[#]+r#a#b,W#g#h,z#k#l.Z~/gR!Q![/p!c!i/p#T#Z/p~/uR!h~!Q![/p!c!i/p#T#Z/pP0TTvP!Q![0O![!]0O!c!}0O#R#S0O#T#o0O~0iP!b~!_!`0l~0qO!c~~0vQw~!_!`0|#r#s1R~1RO!d~~1WOz~~1]P!_~!_!`1`~1eO!a~R1lTvP#cQ!Q![1e![!]0O!c!}1e#R#S1e#T#o1e~2QO$T~~2VO$U~~2[O#i~~2_RO#S2[#S#T%W#T~2[~2mO#o~~2rQ!U~!_!`2x#r#s2}~2}O!R~~3SO!S~~3XO#q~\",\n  tokenizers: [0, 1],\n  topRules: {\"LogQL\":[0,32]},\n  specialized: [{term: 38, get: (value, stack) => (specializeIdentifier(value) << 1), external: specializeIdentifier},{term: 38, get: (value, stack) => (extendIdentifier(value) << 1) | 1, external: extendIdentifier, extend: true},{term: 38, get: value => spec_Identifier[value] || -1}],\n  tokenPrec: 0\n});\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Json = 1,\n  Logfmt = 2,\n  Unpack = 3,\n  Pattern = 4,\n  Regexp = 5,\n  Unwrap = 6,\n  Ip = 7,\n  LabelFormat = 8,\n  LineFormat = 9,\n  LabelReplace = 10,\n  Offset = 11,\n  Bool = 12,\n  On = 13,\n  Ignoring = 14,\n  GroupLeft = 15,\n  GroupRight = 16,\n  By = 17,\n  Without = 18,\n  And = 19,\n  Or = 20,\n  Unless = 21,\n  Sum = 22,\n  Avg = 23,\n  Count = 24,\n  Max = 25,\n  Min = 26,\n  Stddev = 27,\n  Stdvar = 28,\n  Bottomk = 29,\n  Topk = 30,\n  LineComment = 31,\n  LogQL = 32,\n  Expr = 33,\n  LogExpr = 34,\n  Selector = 35,\n  Matchers = 36,\n  Matcher = 37,\n  Identifier = 38,\n  Eq = 39,\n  String = 40,\n  Neq = 41,\n  Re = 42,\n  Nre = 43,\n  PipelineExpr = 44,\n  PipelineStage = 45,\n  LineFilters = 46,\n  LineFilter = 47,\n  Filter = 48,\n  PipeExact = 49,\n  PipeMatch = 50,\n  FilterOp = 51,\n  Pipe = 52,\n  LabelParser = 53,\n  JsonExpressionParser = 54,\n  JsonExpressionList = 55,\n  JsonExpression = 56,\n  LabelFilter = 57,\n  IpLabelFilter = 58,\n  UnitFilter = 59,\n  DurationFilter = 60,\n  Gtr = 61,\n  Duration = 62,\n  Gte = 63,\n  Lss = 64,\n  Lte = 65,\n  Eql = 66,\n  BytesFilter = 67,\n  Bytes = 68,\n  NumberFilter = 69,\n  Number = 70,\n  LineFormatExpr = 71,\n  LabelFormatExpr = 72,\n  LabelsFormat = 73,\n  LabelFormatMatcher = 74,\n  MetricExpr = 75,\n  RangeAggregationExpr = 76,\n  RangeOp = 77,\n  CountOverTime = 78,\n  Rate = 79,\n  RateCounter = 80,\n  BytesOverTime = 81,\n  BytesRate = 82,\n  AvgOverTime = 83,\n  SumOverTime = 84,\n  MinOverTime = 85,\n  MaxOverTime = 86,\n  StddevOverTime = 87,\n  StdvarOverTime = 88,\n  QuantileOverTime = 89,\n  FirstOverTime = 90,\n  LastOverTime = 91,\n  AbsentOverTime = 92,\n  LogRangeExpr = 93,\n  Range = 94,\n  OffsetExpr = 95,\n  UnwrapExpr = 96,\n  ConvOp = 97,\n  BytesConv = 98,\n  DurationConv = 99,\n  DurationSecondsConv = 100,\n  Grouping = 101,\n  Labels = 102,\n  VectorAggregationExpr = 103,\n  VectorOp = 104,\n  BinOpExpr = 105,\n  BinOpModifier = 106,\n  OnOrIgnoringModifier = 107,\n  GroupingLabels = 108,\n  GroupingLabelList = 109,\n  GroupingLabel = 110,\n  LabelName = 111,\n  Add = 112,\n  Sub = 113,\n  Mul = 114,\n  Div = 115,\n  Mod = 116,\n  Pow = 117,\n  LiteralExpr = 118,\n  LabelReplaceExpr = 119;\n\nexport { AbsentOverTime, Add, And, Avg, AvgOverTime, BinOpExpr, BinOpModifier, Bool, Bottomk, By, Bytes, BytesConv, BytesFilter, BytesOverTime, BytesRate, ConvOp, Count, CountOverTime, Div, Duration, DurationConv, DurationFilter, DurationSecondsConv, Eq, Eql, Expr, Filter, FilterOp, FirstOverTime, GroupLeft, GroupRight, Grouping, GroupingLabel, GroupingLabelList, GroupingLabels, Gte, Gtr, Identifier, Ignoring, Ip, IpLabelFilter, Json, JsonExpression, JsonExpressionList, JsonExpressionParser, LabelFilter, LabelFormat, LabelFormatExpr, LabelFormatMatcher, LabelName, LabelParser, LabelReplace, LabelReplaceExpr, Labels, LabelsFormat, LastOverTime, LineComment, LineFilter, LineFilters, LineFormat, LineFormatExpr, LiteralExpr, LogExpr, LogQL, LogRangeExpr, Logfmt, Lss, Lte, Matcher, Matchers, Max, MaxOverTime, MetricExpr, Min, MinOverTime, Mod, Mul, Neq, Nre, Number, NumberFilter, Offset, OffsetExpr, On, OnOrIgnoringModifier, Or, Pattern, Pipe, PipeExact, PipeMatch, PipelineExpr, PipelineStage, Pow, QuantileOverTime, Range, RangeAggregationExpr, RangeOp, Rate, RateCounter, Re, Regexp, Selector, Stddev, StddevOverTime, Stdvar, StdvarOverTime, String, Sub, Sum, SumOverTime, Topk, UnitFilter, Unless, Unpack, Unwrap, UnwrapExpr, VectorAggregationExpr, VectorOp, Without, parser };\n"],"names":["queryTypeOptions","RESOLUTION_OPTIONS","value","LokiOptionFields","props","lineLimitValue","resolution","onRunQuery","runOnBlur","onChange","query","queryType","onChangeQueryLimit","nextQuery","preprocessMaxLines","onQueryTypeChange","instant","range","rest","onMaxLinesChange","e","onReturnKeyDown","onResolutionChange","option","type","DEFAULT_KEYS","EMPTY_SELECTOR","HISTORY_ITEM_COUNT","HISTORY_COUNT_CUTOFF","NS_IN_MS","RATE_RANGES","LABEL_REFRESH_INTERVAL","wrapLabel","label","addHistoryMetadata","item","history","cutoffTs","historyForItem","h","hint","recent","lastQueried","LokiLanguageProvider","datasource","initialValues","s","url","params","error","context","suggestions","suggestion","match","interpolatedMatch","start","end","cacheKey","data","values","syntax","input","wrapperClasses","prefix","text","emptyResult","empty","selectedLines","currentLine","nextCharacter","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","operatorsPattern","isNextOperand","historyItems","labelKey","line","cursorOffset","isValueStart","selector","parsedSelector","allLabels","existingKeys","labelValues","labelValuesForKey","filterText","labelKeys","possibleKeys","newSuggestion","key","labelBasedQuery","lokiQuery","tokens","timeRange","res","labels","forceRefresh","param","nanos","interpolatedKey","rangeParams","series","hasLogfmt","hasJSON","DEFAULT_WEBSOCKET_CONFIG","WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT","WebSocketSubject","_super","urlConfigOrSource","destination","_this","Observable","config","Subject","ReplaySubject","operator","sock","subMsg","unsubMsg","messageFilter","self","observer","err","subscription","x","_a","WebSocketCtor","protocol","binaryType","socket","Subscription","evt","_socket","openObserver","queue","Subscriber","serializer","closingObserver","closeObserver","deserializer","subscriber","source","webSocket","validate","uuid","parse","v","arr","stringToBytes","str","bytes","i","DNS","URL","v35","name","version","hashfunc","generateUUID","namespace","buf","offset","_namespace","f","y","z","ROTL","n","sha1","K","H","msg","l","N","M","j","W","t","a","b","c","d","T","UUID_NAMESPACE","appendResponseToBufferedData","response","streams","tsField","lineField","idField","usedUids","stream","allLabelsString","val","ts","createUid","labelsString","refId","id","newCount","LiveStreams","target","retryInterval","CircularDataFrame","map","retryWhen","attempts","mergeMap","retryAttempt","timer","throwError","finalize","getDerivedFields","dataFrame","derivedFieldConfigs","derivedFieldsGrouped","newFields","fieldFromDerivedFieldConfig","field","logMatch","dataSourceSrv","dataLinks","acc","derivedFieldConfig","dsSettings","ArrayVector","makeTableFrames","instantMetricFrames","framesWithRefId","framesByRefId","frame","frames","makeTableFrame","tableTimeField","tableValueField","allLabelNames","labelFields","labelName","timeField","valueField","timeArray","valueArray","isMetricFrame","setFrameMeta","meta","oldMeta","newMeta","processStreamFrame","custom","newFrame","derivedFields","processStreamsFrames","queryMap","processMetricInstantFrames","processMetricRangeFrames","groupFrames","streamsFrames","metricInstantFrames","metricRangeFrames","improveError","message","transformBackendResult","queries","dataFrames","LokiAnnotationsQueryEditor","annotation","onAnnotationChange","onChangeQuery","queryWithRefId","LokiQueryField","Input","event","getStyles","theme","formatOptionLabel","description","Tooltip","LokiContextUi","row","languageProvider","updateFilter","onClose","styles","contextFilters","setContextFilters","initialized","setInitialized","timerHandle","previousInitialized","useAsync","filter","realLabels","fromParser","realLabelsEnabled","enabled","parsedLabels","parsedLabelsEnabled","Tag","keys","actionMeta","labelNamesRegex","labelValuesRegex","migrateVariableQuery","rawQuery","queryBase","getQueryHints","hints","queryWithParser","parserCount","hasPipelineErrorFiltering","hasLevel","levelLikeLabel","makeIndex","dir","fieldValues","index","isAsc","valA","valB","sortDataFrameByTime","fields","tsNsField","SortedVector","getLiveStreamKey","msgUint8","hashBuffer","doLokiChannelStream","ds","options","maxDelta","maxLength","updateFrame","p","StreamingDataFrame","defer","variableOptions","LokiVariableQueryEditor","setType","setLabel","labelOptions","setLabelOptions","setStream","variableQuery","labelNames","newType","onLabelChange","newLabel","onStreamChange","handleBlur","InlineFieldRow","InlineField","Select","LokiVariableSupport","request","result","from","DEFAULT_MAX_LINES","LOKI_ENDPOINT","REF_ID_DATA_SAMPLES","REF_ID_STARTER_ANNOTATION","REF_ID_STARTER_LOG_ROW_CONTEXT","REF_ID_STARTER_LOG_VOLUME","REF_ID_STARTER_LOG_SAMPLE","makeRequest","app","requestId","hideFromInspector","intervalInfo","LokiDatasource","DataSourceWithBackend","instanceSettings","templateSrv","timeSrv","maxDataPoints","liveTarget","catchError","origQuery","direction","limit","processDataFrame","cache","FieldCache","timestampField","processResults","processedFrames","lastValueFrom","switchMap","of","expr","contextTimeBuffer","queryDirection","tsValue","timestamp","settingsData","normalizedQuery","isQuerySuitable","logsVolumeRequest","targets","extractLevel","logsSampleRequest","q","fixedRequest","streamQueries","streamRequest","merge","startTime","tap","logsQueries","subQueries","baseUrl","msRange","sRange","scopedVars","expandedQueries","abstractQueries","abstractQuery","labelMatcher","labelMatchers","statsForAll","interpolated","interpolatedQuery","lokiLogsQuery","variable","lokiRegularEscape","lokiSpecialRegexEscape","lodash","action","expression","parserPositions","labelFilterPositions","lastPosition","date","roundUp","runContextQuery","parserContextFilters","parser","nowMs","info","maxLines","tagKeys","titleFormat","textFormat","annotations","splitKeys","DataFrameView","maybeDuplicatedTags","tags","queryExpr","adhocFilters","__interval","__interval_ms","exprWithAdHoc","string","getLogLevelFromLabels","levelLabel","addLabelToQuery","streamSelectorPositions","getStreamSelectorPositions","hasStreamSelectorMatchers","getMatcherInStreamPositions","everyStreamSelectorHasMatcher","streamSelectorPosition","matcherPosition","getParserPositions","getLabelFilterPositions","toLabelFilter","positionToAdd","findLastPosition","addFilterAsLabelFilter","addFilterToStreamSelector","addParserToQuery","lineFilterPositions","getLineFiltersPositions","addParser","addNoPipelineErrorToQuery","addLabelFormatToQuery","labelFormat","logQueryPositions","getLogQueryPositions","addLabelFormat","removeCommentsFromQuery","lineCommentPositions","getLineCommentPositions","newQuery","prev","lineCommentPosition","tree","positions","to","node","getAllPositionsInNodeByType","logPartsPositions","pipeline","unwrap","sorted","position","vectorSelectorPositions","modeller","isLast","matchVisQuery","labelExists","newLabels","positionsToAddAfter","labelFilter","queryPartPositions","addLineFilter","streamSelectorEnd","current","pos","child","formatQuery","getHighlighterExpressionsFromQuery","results","filters","pipeExact","pipeMatch","filterTerm","backtickedTerm","unwrappedFilterTerm","resultTerm","getNormalizedLokiQuery","tagsToObscure","partsToKeep","obfuscate","obfuscatedQuery","queryPart","parseToNodeNamesArray","queryParts","isValidQuery","isValid","isLogsQuery","isQueryWithParser","getParserFromQuery","logParser","isQueryPipelineErrorFiltering","isQueryWithLabelFormat","queryWithLabelFormat","getLogQueryFromMetricsQuery","pipelineExpr","isQueryWithLabelFilter","hasLabelFilter","isQueryWithLineFilter","queryWithLineFilter","getStreamSelectorsFromQuery","LokiQueryModeller","lokiQueryModeller","binaryScalarDefs","binaryScalarOperations","opDef","defaultParams","getSimpleBinaryRenderer","model","def","innerExpr","bool","UnwrapParamEditor","operationIndex","state","setState","loadUnwrapOptions","logExpr","samples","createRangeOperation","isRangeOperationWithGrouping","getRangeVectorParamDef","paramChangedHandler","operationWithRangeVectorRenderer","addLokiOperation","op","opDocs","createRangeOperationWithGrouping","rangeOperation","LabelParamEditor","getRangeAggregationWithGroupingRenderer","aggregation","grouping","restParamIndex","restParams","rangeVector","quantile","labelFilterRenderer","pipelineRenderer","isRangeVectorFunction","getIndexOfOrLast","operations","queryModeller","condition","newOperation","existingRangeVectorFunction","placeToInsert","addNestedQueryHandler","getLineFilterRenderer","operation","caseInsensitive","getOperationDefinitions","aggregations","opId","aggregationsWithParam","rangeOperations","rangeOperationsWithGrouping","definitions","explainOperator","getDefinitionById","checkParamsAreValid","buildVisualQueryFromString","replacedExpr","handleExpression","isEmptyQuery","visQuery","getLabel","getLineFilter","createNotSupportedError","getLabelParser","getLabelFilter","getJsonExpressionParser","getLineFormat","getLabelFormat","handleUnwrapExpr","handleRangeAggregation","handleVectorAggregation","handleBinary","isIntervalVariableError","labelNode","filterExpr","handleQuotes","parserNode","ipLabelFilter","valueString","renameTo","originalLabel","unwrapExprChild","labelFilterChild","unwrapChild","convOp","identifier","nameNode","funcName","number","rangeValue","numberNode","metricExpr","operatorToOpName","left","binModifier","getBinaryModifier","right","leftNumber","getLastChildWithSelector","rightNumber","rightBinary","leftMostChild","binQuery","matcher","children","LokiQueryPatternType","LokiVisualQueryOperationCategory","LokiOperationId","LokiOperationOrder","isLogLineJSON","parsed","LOGFMT_REGEXP","isLogLineLogfmt","dataFrameHasLokiError","dataFrameHasLevelLabel","extractLogParserFromDataFrame","logLines","extractLabelKeysFromDataFrame","labelsArray","extractUnwrapLabelKeysFromDataFrame","obj","extractHasErrorLabelFromDataFrame","labelField","extractLevelLikeLabelFromDataFrame","AGGREGATION_OPERATORS","PIPE_PARSERS","PIPE_OPERATORS","RANGE_VEC_FUNCTIONS","FUNCTIONS","LOKI_KEYWORDS","keyword","lokiGrammar","onDashboardLoadedHandler","dashboardId","orgId","grafanaVersion","lokiQueries","metricQueries","instantQueries","rangeQueries","builderModeQueries","codeModeQueries","queriesWithTemplateVariables","isQueryWithTemplateVariables","queriesWithChangedResolution","isQueryWithChangedResolution","queriesWithChangedLineLimit","isQueryWithChangedLineLimit","queriesWithChangedLegend","isQueryWithChangedLegend","shouldNotReportBasedOnRefId","starters","starter","trackQuery","totalBytes","byteKey","stat","LokiResultType","LokiQueryType","LokiQueryDirection","LokiVariableQueryType","SupportingQueryType","QueryEditorMode","Json$1","Logfmt$1","Unpack$1","Pattern$1","Regexp$1","Unwrap$1","Ip$1","LabelFormat$1","LineFormat$1","LabelReplace$1","Offset$1","Bool$1","On$1","Ignoring$1","GroupLeft$1","GroupRight$1","By$1","Without$1","And$1","Or$1","Unless$1","Sum$1","Avg$1","Count$1","Max$1","Min$1","Stddev$1","Stdvar$1","Bottomk$1","Topk$1","keywordTokens","specializeIdentifier","stack","contextualKeywordTokens","extendIdentifier","spec_Identifier","Json","Logfmt","Unpack","Pattern","Regexp","Unwrap","Ip","LabelFormat","LineFormat","LabelReplace","Offset","Bool","On","Ignoring","GroupLeft","GroupRight","By","Without","And","Or","Unless","Sum","Avg","Count","Max","Min","Stddev","Stdvar","Bottomk","Topk","LineComment","LogQL","Expr","LogExpr","Selector","Matchers","Matcher","Identifier","Eq","String","Neq","Re","Nre","PipelineExpr","PipelineStage","LineFilters","LineFilter","Filter","PipeExact","PipeMatch","FilterOp","Pipe","LabelParser","JsonExpressionParser","JsonExpressionList","JsonExpression","LabelFilter","IpLabelFilter","UnitFilter","DurationFilter","Gtr","Duration","Gte","Lss","Lte","Eql","BytesFilter","Bytes","NumberFilter","Number","LineFormatExpr","LabelFormatExpr","LabelsFormat","LabelFormatMatcher","MetricExpr","RangeAggregationExpr","RangeOp","CountOverTime","Rate","RateCounter","BytesOverTime","BytesRate","AvgOverTime","SumOverTime","MinOverTime","MaxOverTime","StddevOverTime","StdvarOverTime","QuantileOverTime","FirstOverTime","LastOverTime","AbsentOverTime","LogRangeExpr","Range","OffsetExpr","UnwrapExpr","ConvOp","BytesConv","DurationConv","DurationSecondsConv","Grouping","Labels","VectorAggregationExpr","VectorOp","BinOpExpr","BinOpModifier","OnOrIgnoringModifier","GroupingLabels","GroupingLabelList","GroupingLabel","LabelName","Add","Sub","Mul","Div","Mod","Pow","LiteralExpr","LabelReplaceExpr"],"sourceRoot":""}